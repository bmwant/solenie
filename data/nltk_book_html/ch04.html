<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>ch04.rst</title>
<--- Cannot embed stylesheet '../nltkdoc.css': No such file or directory. --->
</head>
<body>
<div class="document">


<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
<div class="compound">
</div>
<!-- standard global imports

>>> import nltk, re, pprint
>>> from nltk import word_tokenize -->
<!-- TODO: recipes for flattening a list of lists into a list, and for the reverse grouping a list into a list of lists -->
<!-- TODO: discuss duck typing -->
<!-- TODO: check ch06-extras for further content -->
<!-- TODO: shared values between multiple dictionaries -->
<!-- TODO: general technique for computing transitive closures, e.g.
adjectives connected by synonymy to a particular word, cf.
http://www.aclweb.org/anthology/W04-3253 -->
<!-- TODO: explain function vs method -->
<!-- TODO: say more about performance tuning of a Python program -->
<!-- TODO: add exercises on string formatting -->
<!-- TODO: this chapter presumes knowledge of dictionaries, not defined until ch05 -->
<!-- TODO: the "b" flag for read(), when to use "rb"; also the "rU" flag -->
<div class="section" id="writing-structured-programs">
<span id="chap-structured-programming"></span><h1>4&nbsp;&nbsp;&nbsp;Writing Structured Programs</h1>
<p>By now you will have a sense of the capabilities of the Python programming language
for processing natural language.  However, if you're new to Python or to programming, you may
still be wrestling with Python and not feel like you are in full control yet.  In this chapter we'll
address the following questions:</p>
<ol class="arabic simple">
<li>How can you write well-structured, readable programs that you and others will be able to re-use easily?</li>
<li>How do the fundamental building blocks work, such as loops, functions and assignment?</li>
<li>What are some of the pitfalls with Python programming and how can you avoid them?</li>
</ol>
<p>Along the way, you will consolidate your knowledge of fundamental programming
constructs, learn more about using features of the Python language in a natural
and concise way, and learn some useful techniques in visualizing natural language data.
As before, this chapter contains many examples and
exercises (and as before, some exercises introduce new material).
Readers new to programming should work through them carefully
and consult other introductions to programming if necessary;
experienced programmers can quickly skim this chapter.</p>
<p>In the other chapters of this book, we have organized the programming
concepts as dictated by the needs of NLP.  Here we revert to a more
conventional approach where the material is more closely tied to
the structure of the programming language.  There's not room for
a complete presentation of the language, so we'll just focus on
the language constructs and idioms that are most important for NLP.</p>
<div class="section" id="back-to-the-basics">
<span id="sec-back-to-the-basics"></span><h2>4.1&nbsp;&nbsp;&nbsp;Back to the Basics</h2>
<div class="section" id="assignment">
<h3>Assignment</h3>
<p>Assignment would seem to be the most elementary programming concept, not
deserving a separate discussion.  However, there are some surprising subtleties
here.  Consider the following code fragment:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> foo = 'Monty'
>>> bar = foo # [_assignment1]
>>> foo = 'Python' # [_assignment2]
>>> bar
'Monty'</td>
</tr></table></td></tr>
</table></div>
<p>This behaves exactly as expected.  When we write <tt class="doctest"><span class="pre">bar = foo</span></tt> in the above
code <a class="reference internal" href="#assignment1"><span id="ref-assignment1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
the value of <tt class="doctest"><span class="pre">foo</span></tt> (the string <tt class="doctest"><span class="pre">'Monty'</span></tt>) is assigned to <tt class="doctest"><span class="pre">bar</span></tt>.
That is, <tt class="doctest"><span class="pre">bar</span></tt> is a <a name="copy_index_term" /><span class="termdef">copy</span> of <tt class="doctest"><span class="pre">foo</span></tt>, so when we overwrite
<tt class="doctest"><span class="pre">foo</span></tt> with a new string <tt class="doctest"><span class="pre">'Python'</span></tt> on line <a class="reference internal" href="#assignment2"><span id="ref-assignment2"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>, the value
of <tt class="doctest"><span class="pre">bar</span></tt> is not affected.</p>
<p>However, assignment statements do not always involve making copies in this way.
Assignment always copies the value of an expression, but a value is not
always what you might expect it to be.  In particular,
the &quot;value&quot; of a structured object such as a list is actually just a
<span class="emphasis">reference</span> to the object.  In the following example,
<a class="reference internal" href="#assignment3"><span id="ref-assignment3"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> assigns the reference of <tt class="doctest"><span class="pre">foo</span></tt> to the new variable <tt class="doctest"><span class="pre">bar</span></tt>.
Now when we modify something inside <tt class="doctest"><span class="pre">foo</span></tt> on line <a class="reference internal" href="#assignment4"><span id="ref-assignment4"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>, we can see
that the contents of <tt class="doctest"><span class="pre">bar</span></tt> have also been changed.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> foo = ['Monty', 'Python']
>>> bar = foo # [_assignment3]
>>> foo[1] = 'Bodkin' # [_assignment4]
>>> bar
['Monty', 'Bodkin']</td>
</tr></table></td></tr>
</table></div>
<div class="system-message" id="fig-array-memory">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 98)</p>
<p>Error in &quot;figure&quot; directive:
invalid option value: (option: &quot;scale&quot;; value: '75:100:75')
invalid literal for int() with base 10: '75:100:75'.</p>
<pre class="literal-block">
.. figure:: ../images/array-memory.png
   :scale: 75:100:75

   List Assignment and Computer Memory: Two list objects ``foo`` and ``bar`` reference
   the same location in the computer's memory; updating ``foo`` will also modify ``bar``,
   and vice versa.

</pre>
</div>
<p>The line <tt class="doctest"><span class="pre">bar = foo</span></tt> <a class="reference internal" href="#assignment3"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a> does not copy the contents of the
variable, only its &quot;object reference&quot;.
To understand what is going on here, we need to
know how lists are stored in the computer's memory.
In <a class="reference internal" href="#fig-array-memory">fig-array-memory</a>, we see that a list <tt class="doctest"><span class="pre">foo</span></tt> is
a reference to an object stored at location 3133 (which is
itself a series of pointers to other locations holding strings).
When we assign <tt class="doctest"><span class="pre">bar = foo</span></tt>, it is just the object reference
3133 that gets copied.
This behavior extends to other aspects of the language, such as
parameter passing (<a class="reference internal" href="#sec-functions">4.4</a>).</p>
<!-- XXX add a further sentence spelling out the consequences of this -->
<p>Let's experiment some more, by creating a variable <tt class="doctest"><span class="pre">empty</span></tt> holding the
empty list, then using it three times on the next line.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> empty = []
>>> nested = [empty, empty, empty]
>>> nested
[[], [], []]
>>> nested[1].append('Python')
>>> nested
[['Python'], ['Python'], ['Python']]</td>
</tr></table></td></tr>
</table></div>
<p>Observe that changing one of the items inside our nested list of lists changed them all.
This is because each of the three elements is actually just a reference to one and the
same list in memory.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Use multiplication to create a list of lists: <tt class="doctest"><span class="pre">nested = [[]] * 3</span></tt>.
Now modify one of the elements of the list, and observe that all the
elements are changed.  Use Python's <tt class="doctest"><span class="pre">id()</span></tt> function to find out
the numerical identifier for any object, and verify that
<tt class="doctest"><span class="pre">id(nested[0])</span></tt>, <tt class="doctest"><span class="pre">id(nested[1])</span></tt>, and <tt class="doctest"><span class="pre">id(nested[2])</span></tt> are
all the same.</p>
</div>
<p>Now, notice that when we assign a new value to one of the elements of the list,
it does not propagate to the others:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> nested = [[]] * 3
>>> nested[1].append('Python')
>>> nested[1] = ['Monty']
>>> nested
[['Python'], ['Monty'], ['Python']]</td>
</tr></table></td></tr>
</table></div>
<!-- XXX use callouts? The way that in-place methods work on lists isn't really -->
<!-- explained anywhere as far as I can see. E.g why doesn't ``l2 = l1.append(3)`` do -->
<!-- anything useful. There's a reference below to in-place sorting, but it isn't -->
<!-- explained. -->
<p>We began with a list containing three references to a single empty list object.  Then we
modified that object by appending <tt class="doctest"><span class="pre">'Python'</span></tt> to it, resulting in a list containing
three references to a single list object <tt class="doctest"><span class="pre">['Python']</span></tt>.
Next, we <em>overwrote</em> one of those references with a reference to a new object <tt class="doctest"><span class="pre">['Monty']</span></tt>.
This last step modified one of the three object references inside the nested list.
However, the <tt class="doctest"><span class="pre">['Python']</span></tt> object wasn't changed, and is still referenced from two places in
our nested list of lists.  It is crucial to appreciate this difference between
modifying an object via an object reference, and overwriting an object reference.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Important:</strong>
To copy the items from a list <tt class="doctest"><span class="pre">foo</span></tt> to a new list <tt class="doctest"><span class="pre">bar</span></tt>, you can write
<tt class="doctest"><span class="pre">bar = foo[:]</span></tt>.  This copies the object references inside the list.
To copy a structure without copying any object references, use <tt class="doctest"><span class="pre">copy.deepcopy()</span></tt>.</p>
</div>
</div>
<div class="section" id="equality">
<h3>Equality</h3>
<p>Python provides two ways to check that a pair of items are the same.
The <tt class="doctest"><span class="pre">is</span></tt> operator tests for object identity.  We can use it to
verify our earlier observations about objects.  First we create
a list containing several copies of the same object, and demonstrate
that they are not only identical according to <tt class="doctest"><span class="pre">==</span></tt>, but also
that they are one and the same object:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> size = 5
>>> python = ['Python']
>>> snake_nest = [python] * size
>>> snake_nest[0] == snake_nest[1] == snake_nest[2] == snake_nest[3] == snake_nest[4]
True
>>> snake_nest[0] is snake_nest[1] is snake_nest[2] is snake_nest[3] is snake_nest[4]
True</td>
</tr></table></td></tr>
</table></div>
<p>Now let's put a new python in this nest.  We can easily show that the objects are not
all identical:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> import random
>>> position = random.choice(range(size))
>>> snake_nest[position] = ['Python']
>>> snake_nest
[['Python'], ['Python'], ['Python'], ['Python'], ['Python']]
>>> snake_nest[0] == snake_nest[1] == snake_nest[2] == snake_nest[3] == snake_nest[4]
True
>>> snake_nest[0] is snake_nest[1] is snake_nest[2] is snake_nest[3] is snake_nest[4]
False</td>
</tr></table></td></tr>
</table></div>
<p>You can do several pairwise tests to discover which position contains the interloper,
but the <tt class="doctest"><span class="pre">id()</span></tt> function makes detection easier:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> [id(snake) for snake in snake_nest]
[4557855488, 4557854763, 4557855488, 4557855488, 4557855488]</td>
</tr></table></td></tr>
</table></div>
<p>This reveals that the second item of the list has a distinct identifier.  If you try
running this code snippet yourself, expect to see different numbers in the resulting list,
and also the interloper may be in a different position.</p>
<!-- XXX following remark is potentially very useful, but would benefit from being -->
<!-- amplified slightly. -->
<p>Having two kinds of equality might seem strange.  However, it's really just the
type-token distinction, familiar from natural language, here showing up in
a programming language.</p>
</div>
<div class="section" id="conditionals">
<h3>Conditionals</h3>
<p>In the condition part of an <tt class="doctest"><span class="pre">if</span></tt> statement, a
nonempty string or list is evaluated as true, while an empty string or
list evaluates as false.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> mixed = ['cat', '', ['dog'], []]
>>> for element in mixed:
...     if element:
...         print(element)
...
cat
['dog']</td>
</tr></table></td></tr>
</table></div>
<p>That is, we <em>don't</em> need to say <tt class="doctest"><span class="pre">if len(element) > 0:</span></tt> in the
condition.</p>
<p>What's the difference between using <tt class="doctest"><span class="pre">if...elif</span></tt> as opposed to using
a couple of <tt class="doctest"><span class="pre">if</span></tt> statements in a row? Well, consider the following
situation:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> animals = ['cat', 'dog']
>>> if 'cat' in animals:
...     print(1)
... elif 'dog' in animals:
...     print(2)
...
1</td>
</tr></table></td></tr>
</table></div>
<p>Since the <tt class="doctest"><span class="pre">if</span></tt> clause of the statement is satisfied, Python never
tries to evaluate the <tt class="doctest"><span class="pre">elif</span></tt> clause, so we never get to print out
<tt class="doctest"><span class="pre">2</span></tt>. By contrast, if we replaced the <tt class="doctest"><span class="pre">elif</span></tt> by an <tt class="doctest"><span class="pre">if</span></tt>, then we
would print out both <tt class="doctest"><span class="pre">1</span></tt> and <tt class="doctest"><span class="pre">2</span></tt>. So an <tt class="doctest"><span class="pre">elif</span></tt> clause
potentially gives us more information than a bare <tt class="doctest"><span class="pre">if</span></tt> clause; when
it evaluates to true, it tells us not only that the condition is
satisfied, but also that the condition of the main <tt class="doctest"><span class="pre">if</span></tt> clause was
<em>not</em> satisfied.</p>
<!-- XXX The point above could be made a bit more forcefully like this: -->
<!-- >>> def cond1(l):
...    if 'cat' in l:
...        print(1)
...    elif 'dog' in l:
...        print(2)

>>> def cond2(l):
...    if 'cat' in l:
...        print(1)
...    if 'dog' in l:
...        print(2)

>>> animals = ['cat', 'dog']
>>> cond1(animals)
1
>>> cond2(animals)
1
2 -->
<p>The functions <tt class="doctest"><span class="pre">all()</span></tt> and <tt class="doctest"><span class="pre">any()</span></tt> can be applied to a list (or other sequence) to
check whether all or any items meet some condition:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> sent = ['No', 'good', 'fish', 'goes', 'anywhere', 'without', 'a', 'porpoise', '.']
>>> all(len(w) > 4 for w in sent)
False
>>> any(len(w) > 4 for w in sent)
True</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="sequences">
<span id="sec-sequences"></span><h2>4.2&nbsp;&nbsp;&nbsp;Sequences</h2>
<!-- XXX next sentence is confusing, since you don't in fact use parentheses -->
<!-- Although the point about ("foo") not being a tuple is a good one, I would be -->
<!-- inclined to advise students to use parentheses as well as comma. Cf your -->
<!-- example of the precedence problem in the debugging section later on: -->
<!-- For example, ``"%s.%s.%02d" % "ph.d.", "n", 1`` produces a run-time error -->
<!-- ``TypeError: not enough arguments for format string``.  This is because the -->
<!-- percent operator has higher precedence than -->
<!-- the comma operator.  The fix is to add parentheses in order to -->
<!-- force the required scope. -->
<!-- Just checked the Python Tutorial: -->
<!-- As you see, on output tuples are always enclosed in parentheses, so that nested -->
<!-- tuples are interpreted correctly; they may be input with or without surrounding -->
<!-- parentheses, although often parentheses are necessary anyway (if the tuple is part -->
<!-- of a larger expression). -->
<p>So far, we have seen two kinds of sequence object: strings and lists.  Another
kind of sequence is called a <a name="tuple_index_term" /><span class="termdef">tuple</span>.
Tuples are formed with the comma operator <a class="reference internal" href="#create-tuple"><span id="ref-create-tuple"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, and typically enclosed
using parentheses.  We've actually seen them in the
previous chapters, and sometimes referred to them as &quot;pairs&quot;, since
there were always two members.  However, tuples can have any number
of members.  Like lists and strings, tuples can be indexed <a class="reference internal" href="#index-tuple"><span id="ref-index-tuple"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>
and sliced <a class="reference internal" href="#slice-tuple"><span id="ref-slice-tuple"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>, and have a length <a class="reference internal" href="#length-tuple"><span id="ref-length-tuple"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> t = 'walk', 'fem', 3 # [_create-tuple]
>>> t
('walk', 'fem', 3)
>>> t[0] # [_index-tuple]
'walk'
>>> t[1:] # [_slice-tuple]
('fem', 3)
>>> len(t) # [_length-tuple]
3</td>
</tr></table></td></tr>
</table></div>
<div class="admonition caution">
<p class="first admonition-title">Caution!</p>
<p class="last">Tuples are constructed using the comma operator.  Parentheses are a more
general feature of Python syntax, designed for grouping.
A tuple containing the single element <tt class="doctest"><span class="pre">'snark'</span></tt> is defined by adding a
trailing comma, like this: &quot;<tt class="doctest"><span class="pre">'snark',</span></tt>&quot;.  The empty tuple is a special
case, and is defined using empty parentheses <tt class="doctest"><span class="pre">()</span></tt>.</p>
</div>
<!-- XXX how about making the following contrast: -->
<!-- >>> type(('snark')) -->
<!-- <type 'str'> -->
<!-- >>> type(('snark',)) -->
<!-- <type 'tuple'> -->
<!-- XXX this would be a good place to explain tuple assignment / sequence unpacking -->
<!-- (unless you did in a revision of ch03 - - it is mentioned only in an exercise to -->
<!-- this chapter AF -->
<p>Let's compare strings, lists and tuples directly, and do the indexing, slice, and length
operation on each type:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> raw = 'I turned off the spectroroute'
>>> text = ['I', 'turned', 'off', 'the', 'spectroroute']
>>> pair = (6, 'turned')
>>> raw[2], text[3], pair[1]
('t', 'the', 'turned')
>>> raw[-3:], text[-3:], pair[-3:]
('ute', ['off', 'the', 'spectroroute'], (6, 'turned'))
>>> len(raw), len(text), len(pair)
(29, 5, 2)</td>
</tr></table></td></tr>
</table></div>
<p>Notice in this code sample that we computed multiple values on a
single line, separated by commas.  These comma-separated expressions
are actually just tuples &#8212; Python allows us to omit the
parentheses around tuples if there is no ambiguity. When we print a
tuple, the parentheses are always displayed. By using tuples in this
way, we are implicitly aggregating items together.</p>
<div class="section" id="operating-on-sequence-types">
<h3>Operating on Sequence Types</h3>
<p>We can iterate over the items in a sequence <tt class="doctest"><span class="pre">s</span></tt> in a variety of useful ways,
as shown in <a class="reference internal" href="#tab-python-sequence">4.1</a>.</p>
<span class="target" id="tab-python-sequence"></span><table border="1" class="docutils" id="tab-python-sequence">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Python Expression</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">for item in s</span></tt></td>
<td>iterate over the items of <tt class="doctest"><span class="pre">s</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">for item in sorted(s)</span></tt></td>
<td>iterate over the items of <tt class="doctest"><span class="pre">s</span></tt> in order</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">for item in set(s)</span></tt></td>
<td>iterate over unique elements of <tt class="doctest"><span class="pre">s</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">for item in reversed(s)</span></tt></td>
<td>iterate over elements of <tt class="doctest"><span class="pre">s</span></tt> in reverse</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">for item in set(s).difference(t)</span></tt></td>
<td>iterate over elements of <tt class="doctest"><span class="pre">s</span></tt> not in <tt class="doctest"><span class="pre">t</span></tt></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 4.1</span>: <p>Various ways to iterate over sequences</p>
</p>
</table>
<p>The sequence functions illustrated in <a class="reference internal" href="#tab-python-sequence">4.1</a> can be combined
in various ways; for example, to get unique elements of <tt class="doctest"><span class="pre">s</span></tt> sorted
in reverse, use <tt class="doctest"><span class="pre">reversed(sorted(set(s)))</span></tt>.
We can randomize the contents of a list <tt class="doctest"><span class="pre">s</span></tt> before iterating over
them, using <tt class="doctest"><span class="pre">random.shuffle(s)</span></tt>.</p>
<p>We can convert between these sequence types.  For example,
<tt class="doctest"><span class="pre">tuple(s)</span></tt> converts any kind of sequence into a tuple, and
<tt class="doctest"><span class="pre">list(s)</span></tt> converts any kind of sequence into a list.
We can convert a list of strings to a single string using the
<tt class="doctest"><span class="pre">join()</span></tt> function, e.g. <tt class="doctest"><span class="pre">':'.join(words)</span></tt>.</p>
<p>Some other objects, such as a <tt class="doctest"><span class="pre">FreqDist</span></tt>, can be converted into a
sequence (using <tt class="doctest"><span class="pre">list()</span></tt> or <tt class="doctest"><span class="pre">sorted()</span></tt>) and support iteration, e.g.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> raw = 'Red lorry, yellow lorry, red lorry, yellow lorry.'
>>> text = word_tokenize(raw)
>>> fdist = nltk.FreqDist(text)
>>> sorted(fdist)
[',', '.', 'Red', 'lorry', 'red', 'yellow']
>>> for key in fdist:
...     print(key + ':', fdist[key], end='; ')
...
lorry: 4; red: 1; .: 1; ,: 3; Red: 1; yellow: 2</td>
</tr></table></td></tr>
</table></div>
<p>In the next example, we use tuples to re-arrange the
contents of our list.  (We can omit the parentheses
because the comma has higher precedence than assignment.)</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> words = ['I', 'turned', 'off', 'the', 'spectroroute']
>>> words[2], words[3], words[4] = words[3], words[4], words[2]
>>> words
['I', 'turned', 'the', 'spectroroute', 'off']</td>
</tr></table></td></tr>
</table></div>
<p>This is an idiomatic and readable way to move items inside a list.
It is equivalent to the following traditional way of doing such
tasks that does not use tuples (notice that this method needs a
temporary variable <tt class="doctest"><span class="pre">tmp</span></tt>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> tmp = words[2]
>>> words[2] = words[3]
>>> words[3] = words[4]
>>> words[4] = tmp</td>
</tr></table></td></tr>
</table></div>
<p>As we have seen, Python has sequence functions such as <tt class="doctest"><span class="pre">sorted()</span></tt> and <tt class="doctest"><span class="pre">reversed()</span></tt>
that rearrange the items of a sequence.  There are also functions that
modify the <span class="emphasis">structure</span> of a sequence and which can be handy for
language processing.  Thus, <tt class="doctest"><span class="pre">zip()</span></tt> takes
the items of two or more sequences and &quot;zips&quot; them together into a single list of tuples.
Given a sequence <tt class="doctest"><span class="pre">s</span></tt>, <tt class="doctest"><span class="pre">enumerate(s)</span></tt> returns pairs consisting of
an index and the item at that index.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> words = ['I', 'turned', 'off', 'the', 'spectroroute']
>>> tags = ['noun', 'verb', 'prep', 'det', 'noun']
>>> zip(words, tags)
<zip object at ...>
>>> list(zip(words, tags))
[('I', 'noun'), ('turned', 'verb'), ('off', 'prep'),
('the', 'det'), ('spectroroute', 'noun')]
>>> list(enumerate(words))
[(0, 'I'), (1, 'turned'), (2, 'off'), (3, 'the'), (4, 'spectroroute')]</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is a widespread feature of Python 3 and NLTK 3 to only perform
computation when required (a feature known as &quot;lazy evaluation&quot;).
If you ever see a result like <tt class="doctest"><span class="pre"><zip object at 0x10d005448></span></tt> when
you expect to see a sequence, you can force the object to be
evaluated just by putting it in a context that expects a sequence,
like <tt class="doctest"><span class="pre">list(</span></tt><span class="mathit">x</span><tt class="doctest"><span class="pre">)</span></tt>, or <tt class="doctest"><span class="pre">for item in</span></tt> <span class="mathit">x</span>.</p>
</div>
<p>For some NLP tasks it is necessary to cut up a sequence into two or more parts.
For instance, we might want to &quot;train&quot; a system on 90% of the data and test it
on the remaining 10%.  To do this we decide the location where we want to
cut the data <a class="reference internal" href="#cut-location"><span id="ref-cut-location"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, then cut the sequence at that location <a class="reference internal" href="#cut-sequence"><span id="ref-cut-sequence"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> text = nltk.corpus.nps_chat.words()
>>> cut = int(0.9 * len(text)) # [_cut-location]
>>> training_data, test_data = text[:cut], text[cut:] # [_cut-sequence]
>>> text == training_data + test_data # [_cut-preserve]
True
>>> len(training_data) / len(test_data) # [_cut-ratio]
9.0</td>
</tr></table></td></tr>
</table></div>
<p>We can verify that none of the original data is lost during this process, nor is it duplicated
<a class="reference internal" href="#cut-preserve"><span id="ref-cut-preserve"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.  We can also verify that the ratio of the sizes of the two pieces is what
we intended <a class="reference internal" href="#cut-ratio"><span id="ref-cut-ratio"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>.</p>
</div>
<div class="section" id="combining-different-sequence-types">
<h3>Combining Different Sequence Types</h3>
<p>Let's combine our knowledge of these three sequence types, together with list
comprehensions, to perform the task of sorting the words in a string by
their length.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> words = 'I turned off the spectroroute'.split() # [_string-object]
>>> wordlens = [(len(word), word) for word in words] # [_tuple-comprehension]
>>> wordlens.sort() # [_sort-method]
>>> ' '.join(w for (_, w) in wordlens) # [_discard-length]
'I off the turned spectroroute'</td>
</tr></table></td></tr>
</table></div>
<!-- XXX cf earlier remark about explaining what "in-place" means -->
<p>Each of the above lines of code contains a significant feature.
A simple string is actually an object with methods defined on it such as <tt class="doctest"><span class="pre">split()</span></tt> <a class="reference internal" href="#string-object"><span id="ref-string-object"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
We use a list comprehension to build a list of tuples <a class="reference internal" href="#tuple-comprehension"><span id="ref-tuple-comprehension"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>,
where each tuple consists of a number (the word length) and the
word, e.g. <tt class="doctest"><span class="pre">(3, 'the')</span></tt>.  We use the <tt class="doctest"><span class="pre">sort()</span></tt> method <a class="reference internal" href="#sort-method"><span id="ref-sort-method"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>
to sort the list in-place.  Finally, we discard the length
information and join the words back into a single string <a class="reference internal" href="#discard-length"><span id="ref-discard-length"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>.
(The underscore <a class="reference internal" href="#discard-length"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a> is just a regular Python variable,
but we can use underscore by convention to indicate that we will
not use its value.)</p>
<p>We began by talking about the commonalities in these sequence types,
but the above code illustrates important differences in their
roles.  First, strings appear at the beginning and the end: this is
typical in the context where our program is reading in some text and
producing output for us to read.  Lists and tuples are used in the
middle, but for different purposes.  A list is typically a sequence of
objects all having the <span class="emphasis">same type</span>, of <span class="emphasis">arbitrary length</span>.  We often
use lists to hold sequences of words.  In contrast,
a tuple is typically a collection of objects of <span class="emphasis">different types</span>, of
<span class="emphasis">fixed length</span>.  We often use a tuple to hold a <a name="record_index_term" /><span class="termdef">record</span>,
a collection of different <a name="fields_index_term" /><span class="termdef">fields</span> relating to some entity.
This distinction between the use of lists and tuples takes some
getting used to,
so here is another example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> lexicon = [
...     ('the', 'det', ['Di:', 'D@']),
...     ('off', 'prep', ['Qf', 'O:f'])
... ]</td>
</tr></table></td></tr>
</table></div>
<p>Here, a lexicon is represented as a list because it is a
collection of objects of a single type &#8212; lexical entries &#8212;
of no predetermined length.  An individual entry is represented as a
tuple because it is a collection of objects with different
interpretations, such as the orthographic form, the part of speech,
and the pronunciations (represented in the SAMPA computer-readable
phonetic alphabet <tt class="doctest"><span class="pre">http://www.phon.ucl.ac.uk/home/sampa/</span></tt>).
Note that these pronunciations are stored using a list. (Why?)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A good way to decide when to use tuples vs lists is to ask whether
the interpretation of an item depends on its position.  For example,
a tagged token combines two strings having different interpretation,
and we choose to interpret the first item as the token and the
second item as the tag.  Thus we use tuples like this: <tt class="doctest"><span class="pre">('grail', 'noun')</span></tt>;
a tuple of the form <tt class="doctest"><span class="pre">('noun', 'grail')</span></tt> would be nonsensical since
it would be a word <tt class="doctest"><span class="pre">noun</span></tt> tagged <tt class="doctest"><span class="pre">grail</span></tt>.
In contrast, the elements of a text are all tokens, and position is
not significant.  Thus we use lists like this: <tt class="doctest"><span class="pre">['venetian', 'blind']</span></tt>;
a list of the form <tt class="doctest"><span class="pre">['blind', 'venetian']</span></tt> would be equally valid.
The linguistic meaning of the words might be different, but the
interpretation of list items as tokens is unchanged.</p>
</div>
<p>The distinction between lists and tuples has been described in terms of
usage.  However, there is a more fundamental difference: in Python,
lists are <a name="mutable_index_term" /><span class="termdef">mutable</span>, while tuples are <a name="immutable_index_term" /><span class="termdef">immutable</span>.  In other
words, lists can be modified, while tuples cannot.  Here are some of
the operations on lists that do in-place modification of the list.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> lexicon.sort()
>>> lexicon[1] = ('turned', 'VBD', ['t3:nd', 't3`nd'])
>>> del lexicon[0]</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Convert <tt class="doctest"><span class="pre">lexicon</span></tt> to a tuple, using <tt class="doctest"><span class="pre">lexicon = tuple(lexicon)</span></tt>,
then try each of the above operations, to confirm that none of
them is permitted on tuples.</p>
</div>
</div>
<div class="section" id="generator-expressions">
<h3>Generator Expressions</h3>
<p>We've been making heavy use of list comprehensions, for compact and readable
processing of texts.  Here's an example where we tokenize and normalize a text:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> text = '''"When I use a word," Humpty Dumpty said in rather a scornful tone,
... "it means just what I choose it to mean - neither more nor less."'''
>>> [w.lower() for w in word_tokenize(text)]
['``', 'when', 'i', 'use', 'a', 'word', ',', "''", 'humpty', 'dumpty', 'said', ...]</td>
</tr></table></td></tr>
</table></div>
<p>Suppose we now want to process these words further.  We can do this by inserting the above
expression inside a call to some other function <a class="reference internal" href="#max-comprehension"><span id="ref-max-comprehension"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
but Python allows us to omit the brackets <a class="reference internal" href="#max-generator"><span id="ref-max-generator"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> max([w.lower() for w in word_tokenize(text)]) # [_max-comprehension]
'word'
>>> max(w.lower() for w in word_tokenize(text)) # [_max-generator]
'word'</td>
</tr></table></td></tr>
</table></div>
<p>The second line uses a <a name="generator_expression_index_term" /><span class="termdef">generator expression</span>.  This is more than a notational convenience:
in many language processing situations, generator expressions will be more efficient.
In <a class="reference internal" href="#max-comprehension"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>, storage for the list object must be allocated
before the value of max() is computed.  If the text is
very large, this could be slow.  In <a class="reference internal" href="#max-generator"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>, the data is streamed to the calling
function.  Since the calling function simply has to find the maximum value &#8212; the
word which comes latest in lexicographic sort order &#8212; it can process the stream
of data without having to store anything more than the maximum value seen so far.</p>
</div>
</div>
<div class="section" id="questions-of-style">
<h2>4.3&nbsp;&nbsp;&nbsp;Questions of Style</h2>
<p>Programming is as much an art as a science.  The undisputed &quot;bible&quot; of programming,
a 2,500 page multi-volume work by Donald Knuth, is called
<span class="emphasis">The Art of Computer Programming</span>.  Many books have been written on
<span class="emphasis">Literate Programming</span>, recognizing that humans, not just computers,
must read and understand programs.  Here we pick up on some issues of
programming style that have important ramifications for the readability
of your code, including code layout, procedural vs declarative style,
and the use of loop variables.</p>
<div class="section" id="python-coding-style">
<h3>Python Coding Style</h3>
<p>When writing programs you make many subtle choices about names,
spacing, comments, and so on.  When you look at code written by
other people, needless differences in style make it harder
to interpret the code.  Therefore, the designers of the Python
language have published a style guide for Python code, available
at <tt class="doctest"><span class="pre">http://www.python.org/dev/peps/pep-0008/</span></tt>.
The underlying value presented in the style guide is <span class="emphasis">consistency</span>,
for the purpose of maximizing the readability of code.
We briefly review some of its key recommendations here, and refer
readers to the full guide for detailed discussion with examples.</p>
<!-- XXX use pylisting for following example? -->
<p>Code layout should use four spaces per indentation level.  You should make sure that
when you write Python code in a file, you
avoid tabs for indentation, since these can be misinterpreted by
different text editors and the indentation can be messed up.
Lines should be less than 80 characters long; if necessary you can
break a line inside parentheses, brackets, or braces, because
Python is able to detect that the line continues over to the next line.
If you need to break a line outside parentheses, brackets, or braces,
you can often add extra parentheses, and you can always add a backslash at
the end of the line that is broken:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> if (len(syllables) > 4 and len(syllables[2]) == 3 and
...    syllables[2][2] in [aeiou] and syllables[2][3] == syllables[1][3]):
...     process(syllables)
>>> if len(syllables) > 4 and len(syllables[2]) == 3 and \
...    syllables[2][2] in [aeiou] and syllables[2][3] == syllables[1][3]:
...     process(syllables)</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Typing spaces instead of tabs soon becomes a chore.  Many programming
editors have built-in support for Python, and can automatically indent
code and highlight any syntax errors (including indentation errors).
For a list of Python-aware editors, please see
<tt class="doctest"><span class="pre">http://wiki.python.org/moin/PythonEditors</span></tt>.</p>
</div>
</div>
<div class="section" id="procedural-vs-declarative-style">
<h3>Procedural vs Declarative Style</h3>
<!-- XXX ?? Is this really referring to coding style, or was it originally in a -->
<!-- different context? Make a more clear contrast between coding style and programming -->
<!-- style? -->
<!-- XXX following snippet is first time they've seen += -->
<!-- XXX this section seems to be more oriented towards "Python for C-Programmers" -->
<!-- rather than to novices. -->
<p>We have just seen how the same task can be performed in different
ways, with implications for efficiency.  Another factor influencing
program development is <em>programming style</em>.  Consider the following
program to compute the average length of words in the Brown Corpus:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> tokens = nltk.corpus.brown.words(categories='news')
>>> count = 0
>>> total = 0
>>> for token in tokens:
...     count += 1
...     total += len(token)
>>> total / count
4.401545438271973</td>
</tr></table></td></tr>
</table></div>
<!-- XXX above is first use of +=, so needs explaining -->
<p>In this program we use the variable <tt class="doctest"><span class="pre">count</span></tt> to keep track of the
number of tokens seen, and <tt class="doctest"><span class="pre">total</span></tt> to store the combined length of
all words.  This is a low-level style, not far removed from machine
code, the primitive operations performed by the computer's CPU.
The two variables are just like a CPU's registers, accumulating values
at many intermediate stages, values that are meaningless until the end.
We say that this program is written in a <em>procedural</em> style, dictating
the machine operations step by step.  Now consider the following
program that computes the same thing:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> total = sum(len(t) for t in tokens)
>>> print(total / len(tokens))
4.401...</td>
</tr></table></td></tr>
</table></div>
<!-- Monkey patching so that the next example doesn't take forever
>>> tokens = "the cat sat on the mat".split() -->
<p>The first line uses a generator expression to sum the token lengths,
while the second line computes the average as before.
Each line of code performs a complete, meaningful task, which
can be understood in terms of high-level properties like:
&quot;<tt class="doctest"><span class="pre">total</span></tt> is the sum of the lengths of the tokens&quot;.
Implementation details are left to the Python interpreter.
The second program uses a built-in function, and constitutes
programming at a more abstract level; the resulting code is
more declarative.  Let's look at an extreme example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> word_list = []
>>> i = 0
>>> while i < len(tokens):
...     j = 0
...     while j < len(word_list) and word_list[j] <= tokens[i]:
...         j += 1
...     if j == 0 or tokens[i] != word_list[j-1]:
...         word_list.insert(j, tokens[i])
...     i += 1
...</td>
</tr></table></td></tr>
</table></div>
<p>The equivalent declarative version uses familiar built-in functions,
and its purpose is instantly recognizable:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> word_list = sorted(set(tokens))</td>
</tr></table></td></tr>
</table></div>
<!-- XXX you are taking for granted that the reader already knows what a loop variable is. -->
<p>Another case where a loop variable seems to be necessary is for printing
a counter with each line of output.  Instead, we can use <tt class="doctest"><span class="pre">enumerate()</span></tt>, which
processes a sequence <tt class="doctest"><span class="pre">s</span></tt> and produces a tuple of the form <tt class="doctest"><span class="pre">(i, s[i])</span></tt> for each
item in <tt class="doctest"><span class="pre">s</span></tt>, starting with <tt class="doctest"><span class="pre">(0, s[0])</span></tt>.  Here we enumerate the key-value pairs of the
frequency distribution, resulting in nested tuples <tt class="doctest"><span class="pre">(rank, (word, count))</span></tt>.
We print <tt class="doctest"><span class="pre">rank+1</span></tt> so that the counting appears to start from <tt class="doctest"><span class="pre">1</span></tt>,
as required when producing a list of ranked items.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> fd = nltk.FreqDist(nltk.corpus.brown.words())
>>> cumulative = 0.0
>>> most_common_words = [word for (word, count) in fd.most_common()]
>>> for rank, word in enumerate(most_common_words):
...     cumulative += fd.freq(word)
...     print("%3d %6.2f%% %s" % (rank + 1, cumulative * 100, word))
...     if cumulative > 0.25:
...         break
...
  1   5.40% the
  2  10.42% ,
  3  14.67% .
  4  17.78% of
  5  20.19% and
  6  22.40% to
  7  24.29% a
  8  25.97% in</td>
</tr></table></td></tr>
</table></div>
<p>It's sometimes tempting to use loop variables to store a maximum or minimum value
seen so far.  Let's use this method to find the longest word in a text.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> text = nltk.corpus.gutenberg.words('milton-paradise.txt')
>>> longest = ''
>>> for word in text:
...     if len(word) > len(longest):
...         longest = word
>>> longest
'unextinguishable'</td>
</tr></table></td></tr>
</table></div>
<p>However, a more transparent solution uses two list comprehensions,
both having forms that should be familiar by now:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> maxlen = max(len(word) for word in text)
>>> [word for word in text if len(word) == maxlen]
['unextinguishable', 'transubstantiate', 'inextinguishable', 'incomprehensible']</td>
</tr></table></td></tr>
</table></div>
<p>Note that our first solution found the first word having the longest length, while the
second solution found <em>all</em> of the longest words (which is usually what we would want).
Although there's a theoretical efficiency difference between the two solutions,
the main overhead is reading the data into main memory; once it's there, a second pass
through the data is effectively instantaneous.  We also need to balance our concerns about
program efficiency with programmer efficiency.  A fast but cryptic solution
will be harder to understand and maintain.</p>
</div>
<div class="section" id="some-legitimate-uses-for-counters">
<h3>Some Legitimate Uses for Counters</h3>
<!-- XXX it just struck me that we don't seem to explain range() at any point, tho' -->
<!-- it's used a couple of times in ch03 (added exercise to ch01; also mentioned in ch02). -->
<p>There are cases where we still want to use loop variables in a list comprehension.
For example, we need to use a loop variable to extract successive overlapping n-grams
from a list:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> sent = ['The', 'dog', 'gave', 'John', 'the', 'newspaper']
>>> n = 3
>>> [sent[i:i+n] for i in range(len(sent)-n+1)]
[['The', 'dog', 'gave'],
 ['dog', 'gave', 'John'],
 ['gave', 'John', 'the'],
 ['John', 'the', 'newspaper']]</td>
</tr></table></td></tr>
</table></div>
<p>It is quite tricky to get the range of the loop variable right.
Since this is a common operation in NLP, NLTK
supports it with functions <tt class="doctest"><span class="pre">bigrams(text)</span></tt> and <tt class="doctest"><span class="pre">trigrams(text)</span></tt>, and
a general purpose <tt class="doctest"><span class="pre">ngrams(text, n)</span></tt>.</p>
<p>Here's an example of how we can use loop variables in
building multidimensional structures.
For example, to build an array with <em>m</em> rows and <em>n</em> columns,
where each cell is a set, we could use a nested list comprehension:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> m, n = 3, 7
>>> array = [[set() for i in range(n)] for j in range(m)]
>>> array[2][5].add('Alice')
>>> pprint.pprint(array)
[[set(), set(), set(), set(), set(), set(), set()],
 [set(), set(), set(), set(), set(), set(), set()],
 [set(), set(), set(), set(), set(), {'Alice'}, set()]]</td>
</tr></table></td></tr>
</table></div>
<p>Observe that the loop variables <tt class="doctest"><span class="pre">i</span></tt> and <tt class="doctest"><span class="pre">j</span></tt> are not used
anywhere in the resulting object, they are just needed for a syntactically
correct <tt class="doctest"><span class="pre">for</span></tt> statement.  As another example of this usage, observe
that the expression <tt class="doctest"><span class="pre">['very' for i in range(3)]</span></tt> produces a list
containing three instances of <tt class="doctest"><span class="pre">'very'</span></tt>, with no integers in sight.</p>
<p>Note that it would be incorrect to do this work using multiplication,
for reasons concerning object copying that were discussed earlier in this section.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> array = [[set()] * n] * m
>>> array[2][5].add(7)
>>> pprint.pprint(array)
[[{7}, {7}, {7}, {7}, {7}, {7}, {7}],
 [{7}, {7}, {7}, {7}, {7}, {7}, {7}],
 [{7}, {7}, {7}, {7}, {7}, {7}, {7}]]</td>
</tr></table></td></tr>
</table></div>
<!-- XXX this seems to more of an opening statement that a closing one - - since it -->
<!-- assumes the reader already knows some other languages -->
<p>Iteration is an important programming device.
It is tempting to adopt idioms from other languages.
However, Python offers some elegant and highly readable alternatives,
as we have seen.</p>
</div>
</div>
<div class="section" id="functions-the-foundation-of-structured-programming">
<span id="sec-functions"></span><h2>4.4&nbsp;&nbsp;&nbsp;Functions: The Foundation of Structured Programming</h2>
<!-- XXX excessive duplication of information that was already presented in ch02; -->
<!-- e.g. motivation for functions, terminology of 'parameter' and 'body', return -->
<!-- statement etc.  (some collapsing) -->
<p>Functions provide an effective way to package and re-use program code,
as already explained in <a href="#id9"><span class="problematic" id="id10">sec-reusing-code_</span></a>.
For example, suppose we find that we often want to read text from an HTML file.
This involves several steps: opening the file, reading it in, normalizing
whitespace, and stripping HTML markup.  We can collect these steps into a
function, and give it a name such as <tt class="doctest"><span class="pre">get_text()</span></tt>, as shown in <a class="reference internal" href="#code-get-text">4.1</a>.</p>
<span class="target" id="code-get-text"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">import re
def get_text(file):
    """Read text from a file, normalizing whitespace and stripping HTML markup."""
    text = open(file).read()
    text = re.sub(r'<.*?>', ' ', text)
    text = re.sub('\s+', ' ', text)
    return text</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_get_text.py" type="text/x-python"><span class="caption-label">Example 4.1 (code_get_text.py)</span></a>: <span class="caption-label">Figure 4.1</span>: Read text from a file</td></tr></p>
</table></div>
<p>Now, any time we want to get cleaned-up text from an HTML file, we can just call
<tt class="doctest"><span class="pre">get_text()</span></tt> with the name of the file as its only argument.  It will return
a string, and we can assign this to a variable, e.g.:
<tt class="doctest"><span class="pre">contents = get_text("test.html")</span></tt>.  Each time we want to use this series of
steps we only have to call the function.</p>
<p>Using functions has the benefit of saving space in our program.  More
importantly, our choice of name for the function helps make the program <em>readable</em>.
In the case of the above example, whenever our program needs to read cleaned-up
text from a file we don't have to clutter the program with four lines of code, we
simply need to call <tt class="doctest"><span class="pre">get_text()</span></tt>.  This naming helps to provide some &quot;semantic
interpretation&quot; &#8212; it helps a reader of our program to see what the program &quot;means&quot;.</p>
<p>Notice that the above function definition contains a string.  The first string inside
a function definition is called a <a name="docstring_index_term" /><span class="termdef">docstring</span>.  Not only does it document the
purpose of the function to someone reading the code, it is accessible to a programmer
who has loaded the code from a file:</p>
<pre class="literal-block">
|   &gt;&gt;&gt; help(get_text)
|   Help on function get_text in module __main__:
|
|   get(text)
|       Read text from a file, normalizing whitespace and stripping HTML markup.
</pre>
<p>We have seen that functions help to make our work reusable and readable.  They
also help make it <em>reliable</em>.  When we re-use code that has already been developed
and tested, we can be more confident that it handles a variety of cases correctly.
We also remove the risk that we forget some important step, or introduce a bug.
The program that calls our function also has increased reliability.  The author
of that program is dealing with a shorter program, and its components behave
transparently.</p>
<p>To summarize, as its name suggests, a function captures functionality.
It is a segment of code that can be given a meaningful name and which performs
a well-defined task.  Functions allow us to abstract away from the details,
to see a bigger picture, and to program more effectively.</p>
<p>The rest of this section takes a closer look at functions, exploring the
mechanics and discussing ways to make your programs easier to read.</p>
<div class="section" id="function-inputs-and-outputs">
<h3>Function Inputs and Outputs</h3>
<p>We pass information to functions using a function's parameters,
the parenthesized list of variables and constants following
the function's name in the function definition.  Here's a complete example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def repeat(msg, num):  # [_fun-def]
...     return ' '.join([msg] * num)
>>> monty = 'Monty Python'
>>> repeat(monty, 3) # [_fun-call]
'Monty Python Monty Python Monty Python'</td>
</tr></table></td></tr>
</table></div>
<p>We first define the function to take two parameters, <tt class="doctest"><span class="pre">msg</span></tt> and <tt class="doctest"><span class="pre">num</span></tt>
<a class="reference internal" href="#fun-def"><span id="ref-fun-def"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>. Then we call the function and pass it two arguments, <tt class="doctest"><span class="pre">monty</span></tt> and <tt class="doctest"><span class="pre">3</span></tt>
<a class="reference internal" href="#fun-call"><span id="ref-fun-call"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>; these arguments fill the &quot;placeholders&quot; provided by the parameters and
provide values for the occurrences of <tt class="doctest"><span class="pre">msg</span></tt> and <tt class="doctest"><span class="pre">num</span></tt> in the function body.</p>
<p>It is not necessary to have any parameters, as we see in the following example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def monty():
...     return "Monty Python"
>>> monty()
'Monty Python'</td>
</tr></table></td></tr>
</table></div>
<p>A function usually communicates its results back to the calling program via the <tt class="doctest"><span class="pre">return</span></tt> statement,
as we have just seen.  To the calling program, it looks as if the function call had been replaced
with the function's result, e.g.:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> repeat(monty(), 3)
'Monty Python Monty Python Monty Python'
>>> repeat('Monty Python', 3)
'Monty Python Monty Python Monty Python'</td>
</tr></table></td></tr>
</table></div>
<p>A Python function is not required to have a return statement.
Some functions do their work as a side effect, printing a result,
modifying a file, or updating the contents of a parameter to the function
(such functions are called &quot;procedures&quot; in some other programming languages).</p>
<!-- XXX these examples would be easier for a novice to grasp if they knew more about -->
<!-- how functions are used in context. For example, they need to first know that you might -->
<!-- want to write ``foo = my_sort2(l)`` or have a function that only produces -->
<!-- side-effects before they see the significance of these. -->
<p>Consider the following three sort functions.
The third one is dangerous because a programmer could
use it without realizing that it had modified its input.
In general, functions should modify the contents of a parameter
(<tt class="doctest"><span class="pre">my_sort1()</span></tt>), or return a value (<tt class="doctest"><span class="pre">my_sort2()</span></tt>),
not both (<tt class="doctest"><span class="pre">my_sort3()</span></tt>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def my_sort1(mylist):      # good: modifies its argument, no return value
...     mylist.sort()
>>> def my_sort2(mylist):      # good: doesn't touch its argument, returns value
...     return sorted(mylist)
>>> def my_sort3(mylist):      # bad: modifies its argument and also returns it
...     mylist.sort()
...     return mylist</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="parameter-passing">
<h3>Parameter Passing</h3>
<p>Back in <a class="reference internal" href="#sec-back-to-the-basics">4.1</a> you saw that assignment works on values,
but that the value of a structured object is a <span class="emphasis">reference</span> to that object.  The same
is true for functions.  Python interprets function parameters as values (this is
known as <a name="call_by_value_index_term" /><span class="termdef">call-by-value</span>).  In the following code, <tt class="doctest"><span class="pre">set_up()</span></tt> has two parameters,
both of which are modified inside the function.  We begin by assigning an empty string
to <tt class="doctest"><span class="pre">w</span></tt> and an empty list to <tt class="doctest"><span class="pre">p</span></tt>.  After calling the function, <tt class="doctest"><span class="pre">w</span></tt> is unchanged,
while <tt class="doctest"><span class="pre">p</span></tt> is changed:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def set_up(word, properties):
...     word = 'lolcat'
...     properties.append('noun')
...     properties = 5
...
>>> w = ''
>>> p = []
>>> set_up(w, p)
>>> w
''
>>> p
['noun']</td>
</tr></table></td></tr>
</table></div>
<p>Notice that <tt class="doctest"><span class="pre">w</span></tt> was not changed by the function.
When we called <tt class="doctest"><span class="pre">set_up(w, p)</span></tt>, the value of <tt class="doctest"><span class="pre">w</span></tt> (an empty string) was assigned to
a new variable <tt class="doctest"><span class="pre">word</span></tt>.  Inside the function, the value of <tt class="doctest"><span class="pre">word</span></tt> was modified.
However, that change did not propagate to <tt class="doctest"><span class="pre">w</span></tt>.  This parameter passing is
identical to the following sequence of assignments:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> w = ''
>>> word = w
>>> word = 'lolcat'
>>> w
''</td>
</tr></table></td></tr>
</table></div>
<p>Let's look at what happened with the list <tt class="doctest"><span class="pre">p</span></tt>.
When we called <tt class="doctest"><span class="pre">set_up(w, p)</span></tt>, the value of <tt class="doctest"><span class="pre">p</span></tt> (a reference to an empty
list) was assigned to a new local variable <tt class="doctest"><span class="pre">properties</span></tt>,
so both variables now reference the same memory location.
The function modifies <tt class="doctest"><span class="pre">properties</span></tt>, and this change is also
reflected in the value of <tt class="doctest"><span class="pre">p</span></tt> as we saw.  The function also
assigned a new value to properties (the number <tt class="doctest"><span class="pre">5</span></tt>); this
did not modify the contents at that memory location, but
created a new local variable.
This behavior is just as if we had done the following sequence of assignments:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> p = []
>>> properties = p
>>> properties.append('noun')
>>> properties = 5
>>> p
['noun']</td>
</tr></table></td></tr>
</table></div>
<p>Thus, to understand Python's call-by-value parameter passing,
it is enough to understand how assignment works.  Remember that you
can use the <tt class="doctest"><span class="pre">id()</span></tt> function and <tt class="doctest"><span class="pre">is</span></tt> operator to check your
understanding of object identity after each statement.</p>
</div>
<div class="section" id="variable-scope">
<h3>Variable Scope</h3>
<p>Function definitions create a new, local <a name="scope_index_term" /><span class="termdef">scope</span> for variables.
When you assign to a new variable inside the body of a function,
the name is only defined within that function.  The name is not
visible outside the function, or in other functions.  This behavior
means you can choose variable names without being concerned about
collisions with names used in your other function definitions.</p>
<p>When you refer to an existing name from within the body
of a function, the Python interpreter first tries to resolve
the name with respect to the names that are local to the function.
If nothing is found, the interpreter checks if it is a global
name within the module.  Finally, if that does not succeed, the
interpreter checks if the name is a Python built-in.  This is
the so-called <a name="lgb_rule_index_term" /><span class="termdef">LGB rule</span> of name resolution: local,
then global, then built-in.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution!</p>
<p class="last">A function can enable access to a global variable using the
<tt class="doctest"><span class="pre">global</span></tt> declaration.  However, this practice should be
avoided as much as possible.  Defining global variables
inside a function introduces dependencies on context
and limits the portability (or reusability) of the function.
In general you should use parameters for function inputs
and return values for function outputs.</p>
</div>
</div>
<div class="section" id="checking-parameter-types">
<h3>Checking Parameter Types</h3>
<p>Python does not allow us to declare the type of a variable when we write a program,
and this permits us to define functions that are flexible
about the type of their arguments.  For example, a tagger might expect
a sequence of words, but it wouldn't care whether this sequence is expressed
as a list or a tuple (or an iterator, another sequence type that is
outside the scope of the current discussion).</p>
<p>However, often we want to write programs for later use by others, and want
to program in a defensive style, providing useful warnings when functions
have not been invoked correctly.  The author of the following <tt class="doctest"><span class="pre">tag()</span></tt>
function assumed that its argument would always be a string.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def tag(word):
...     if word in ['a', 'the', 'all']:
...         return 'det'
...     else:
...         return 'noun'
...
>>> tag('the')
'det'
>>> tag('knight')
'noun'
>>> tag(["'Tis", 'but', 'a', 'scratch']) # [_list-arg]
'noun'</td>
</tr></table></td></tr>
</table></div>
<p>The function returns sensible values for the arguments <tt class="doctest"><span class="pre">'the'</span></tt> and <tt class="doctest"><span class="pre">'knight'</span></tt>,
but look what happens when it is passed a list <a class="reference internal" href="#list-arg"><span id="ref-list-arg"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> &#8212; it fails to
complain, even though the result which it returns is clearly incorrect.
The author of this function could take some extra steps to
ensure that the <tt class="doctest"><span class="pre">word</span></tt> parameter of the <tt class="doctest"><span class="pre">tag()</span></tt> function is a string.
A naive approach would be to check the type of the argument using
<tt class="doctest"><span class="pre">if not type(word) is str</span></tt>, and if <tt class="doctest"><span class="pre">word</span></tt> is not a string, to simply
return Python's special empty value, <tt class="doctest"><span class="pre">None</span></tt>. This is a slight improvement, because
the function is checking the type of the argument, and trying to return a &quot;special&quot;, diagnostic
value for the wrong input.
However, it is also dangerous because the calling program
may not detect that <tt class="doctest"><span class="pre">None</span></tt> is intended as a &quot;special&quot; value, and this diagnostic
return value may then be
propagated to other parts of the program with unpredictable consequences.
This approach also fails if the word is a Unicode string, which has
type <tt class="doctest"><span class="pre">unicode</span></tt>, not <tt class="doctest"><span class="pre">str</span></tt>.
Here's a better solution, using an <tt class="doctest"><span class="pre">assert</span></tt> statement together with Python's <tt class="doctest"><span class="pre">basestring</span></tt>
type that generalizes over both <tt class="doctest"><span class="pre">unicode</span></tt> and <tt class="doctest"><span class="pre">str</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def tag(word):
...     assert isinstance(word, basestring), "argument to tag() must be a string"
...     if word in ['a', 'the', 'all']:
...         return 'det'
...     else:
...         return 'noun'</td>
</tr></table></td></tr>
</table></div>
<p>If the <tt class="doctest"><span class="pre">assert</span></tt> statement fails, it will produce an error that cannot be ignored,
since it halts program execution.
Additionally, the error message is easy to interpret.  Adding assertions to
a program helps you find logical errors, and is a kind of <a name="defensive_programming_index_term" /><span class="termdef">defensive programming</span>.
A more fundamental approach is to document the parameters to each function
using docstrings as described later in this section.</p>
<!-- XXX should we mention try / except here? -->
</div>
<div class="section" id="functional-decomposition">
<h3>Functional Decomposition</h3>
<p>Well-structured programs usually make extensive use of functions.
When a block of program code grows longer than 10-20 lines, it is a
great help to readability if the code is broken up into one or more
functions, each one having a clear purpose.  This is analogous to
the way a good essay is divided into paragraphs, each expressing one main idea.</p>
<!-- XXX not clear here whether you are really talking about actions (in which case -->
<!-- :lx: role is maybe inappropriate / misleading) or about lexical semantics. -->
<!-- XXX the following code snippet could well occur earlier, e.g in section where you -->
<!-- talk about function inputs and outputs, so as to motivate different kinds of -->
<!-- return values, and then perhaps repeated here. -->
<p>Functions provide an important kind of abstraction.
They allow us to group multiple actions into a single, complex action,
and associate a name with it.
(Compare this with the way we combine the actions of
<span class="example">go</span> and <span class="example">bring back</span> into a single more complex action <span class="example">fetch</span>.)
When we use functions, the main program can be written at a higher level
of abstraction, making its structure transparent, e.g.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> data = load_corpus()
>>> results = analyze(data)
>>> present(results)</td>
</tr></table></td></tr>
</table></div>
<p>Appropriate use of functions makes programs more readable and maintainable.
Additionally, it becomes possible to reimplement a function
&#8212; replacing the function's body with more efficient code &#8212;
without having to be concerned with the rest of the program.</p>
<p>Consider the <tt class="doctest"><span class="pre">freq_words</span></tt> function in <a class="reference internal" href="#code-freq-words1">4.2</a>.
It updates the contents of a frequency distribution that is
passed in as a parameter, and it also prints a list of the
<span class="math">n</span> most frequent words.</p>
<span class="target" id="code-freq-words1"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">from urllib import request
from bs4 import BeautifulSoup

def freq_words(url, freqdist, n):
    html = request.urlopen(url).read().decode('utf8')
    raw = BeautifulSoup(html, 'html.parser').get_text()
    for word in word_tokenize(raw):
        freqdist[word.lower()] += 1
    result = []
    for word, count in freqdist.most_common(n):
        result = result + [word]
    print(result)</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> constitution = "http://www.archives.gov/exhibits/charters/constitution_transcript.html"
>>> fd = nltk.FreqDist()
>>> freq_words(constitution, fd, 30)
['the', ',', 'of', 'and', 'shall', '.', 'be', 'to', ';', 'in', 'states',
'or', 'united', 'a', 'state', 'by', 'for', 'any', '=', 'which', 'president',
'all', 'on', 'may', 'such', 'as', 'have', ')', '(', 'congress']</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_freq_words1.py" type="text/x-python"><span class="caption-label">Example 4.2 (code_freq_words1.py)</span></a>: <span class="caption-label">Figure 4.2</span>: Poorly Designed Function to Compute Frequent Words</td></tr></p>
</table></div>
<p>This function has a number of problems.
The function has two side-effects: it modifies the contents of its second
parameter, and it prints a selection of the results it has computed.
The function would be easier to understand and to reuse elsewhere if we
initialize the <tt class="doctest"><span class="pre">FreqDist()</span></tt> object inside the function (in the same place
it is populated), and if we moved the selection and display of results to the
calling program. Given that its task is to identify frequent words, it
should probably just return a list, not the whole frequency distribution.
In <a class="reference internal" href="#code-freq-words2">4.3</a> we <a name="refactor_index_term" /><span class="termdef">refactor</span> this function,
and simplify its interface by dropping the <tt class="doctest"><span class="pre">freqdist</span></tt> parameter.</p>
<span class="target" id="code-freq-words2"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">from urllib import request
from bs4 import BeautifulSoup

def freq_words(url, n):
    html = request.urlopen(url).read().decode('utf8')
    text = BeautifulSoup(html, 'html.parser').get_text()
    freqdist = nltk.FreqDist(word.lower() for word in word_tokenize(text))
    return [word for (word, _) in fd.most_common(n)]</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> freq_words(constitution, 30)
['the', ',', 'of', 'and', 'shall', '.', 'be', 'to', ';', 'in', 'states',
'or', 'united', 'a', 'state', 'by', 'for', 'any', '=', 'which', 'president',
'all', 'on', 'may', 'such', 'as', 'have', ')', '(', 'congress']</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_freq_words2.py" type="text/x-python"><span class="caption-label">Example 4.3 (code_freq_words2.py)</span></a>: <span class="caption-label">Figure 4.3</span>: Well-Designed Function to Compute Frequent Words</td></tr></p>
</table></div>
<p>The readability and usability of the <tt class="doctest"><span class="pre">freq_words</span></tt> function is improved.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We have used <tt class="doctest"><span class="pre">_</span></tt> as a variable name. This is no different to any other
variable except it signals to the reader that we don't have a use
for the information it holds.</p>
</div>
</div>
<div class="section" id="documenting-functions">
<h3>Documenting Functions</h3>
<p>If we have done a good job at decomposing our program into functions, then it should
be easy to describe the purpose of each function in plain language, and provide
this in the docstring at the top of the function definition.  This statement
should not explain how the functionality is implemented; in fact it should be possible
to re-implement the function using a different method without changing this
statement.</p>
<p>For the simplest functions, a one-line docstring is usually adequate (see <a class="reference internal" href="#code-get-text">4.1</a>).
You should provide a triple-quoted string containing a complete sentence on a single line.
For non-trivial functions, you should still provide a one sentence summary on the first line,
since many docstring processing tools index this string.  This should be followed by
a blank line, then a more detailed description of the functionality
(see <tt class="doctest"><span class="pre">http://www.python.org/dev/peps/pep-0257/</span></tt> for more information in docstring
conventions).</p>
<!-- XXX it would be really nice to have a screen dump of the HTML output. -->
<p>Docstrings can include a <a name="doctest_block_index_term" /><span class="termdef">doctest block</span>, illustrating the use of
the function and the expected output.  These can be tested automatically
using Python's <tt class="doctest"><span class="pre">docutils</span></tt> module.
Docstrings should document the type of each parameter to the function, and the return
type.  At a minimum, that can be done in plain text.  However, note that NLTK uses
the Sphinx markup language to document parameters.  This format
can be automatically converted into richly structured
API documentation (see <tt class="doctest"><span class="pre">http://nltk.org/</span></tt>), and includes special handling of certain
&quot;fields&quot; such as <tt class="doctest"><span class="pre">param</span></tt> which allow the inputs and outputs of functions to be
clearly documented.  <a class="reference internal" href="#code-sphinx">4.4</a> illustrates
a complete docstring.</p>
<span class="target" id="code-sphinx"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">def accuracy(reference, test):
    """
    Calculate the fraction of test items that equal the corresponding reference items.

    Given a list of reference values and a corresponding list of test values,
    return the fraction of corresponding values that are equal.
    In particular, return the fraction of indexes
    {0<i<=len(test)} such that C{test[i] == reference[i]}.

        >>> accuracy(['ADJ', 'N', 'V', 'N'], ['N', 'N', 'V', 'ADJ'])
        0.5

    :param reference: An ordered list of reference values
    :type reference: list
    :param test: A list of values to compare against the corresponding
        reference values
    :type test: list
    :return: the accuracy score
    :rtype: float
    :raises ValueError: If reference and length do not have the same length
    """

    if len(reference) != len(test):
        raise ValueError("Lists must have the same length.")
    num_correct = 0
    for x, y in zip(reference, test):
        if x == y:
            num_correct += 1
    return float(num_correct) / len(reference)</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_sphinx.py" type="text/x-python"><span class="caption-label">Example 4.4 (code_sphinx.py)</span></a>: <span class="caption-label">Figure 4.4</span>: Illustration of a complete docstring, consisting of a one-line summary,
a more detailed explanation, a doctest example, and Sphinx markup
specifying the parameters, types, return type, and exceptions.</td></tr></p>
</table></div>
</div>
</div>
<div class="section" id="doing-more-with-functions">
<span id="sec-doing-more-with-functions"></span><h2>4.5&nbsp;&nbsp;&nbsp;Doing More with Functions</h2>
<p>This section discusses more advanced features, which you may prefer to skip on the
first time through this chapter.</p>
<div class="section" id="functions-as-arguments">
<h3>Functions as Arguments</h3>
<p>So far the arguments we have passed into functions have been simple objects like
strings, or structured objects like lists.  Python also lets us pass a function as
an argument to another function.  Now we can abstract out the operation, and apply
a <span class="emphasis">different operation</span> on the <span class="emphasis">same data</span>.  As the following examples show,
we can pass the built-in function <tt class="doctest"><span class="pre">len()</span></tt> or a user-defined function <tt class="doctest"><span class="pre">last_letter()</span></tt>
as arguments to another function:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> sent = ['Take', 'care', 'of', 'the', 'sense', ',', 'and', 'the',
...         'sounds', 'will', 'take', 'care', 'of', 'themselves', '.']
>>> def extract_property(prop):
...     return [prop(word) for word in sent]
...
>>> extract_property(len)
[4, 4, 2, 3, 5, 1, 3, 3, 6, 4, 4, 4, 2, 10, 1]
>>> def last_letter(word):
...     return word[-1]
>>> extract_property(last_letter)
['e', 'e', 'f', 'e', 'e', ',', 'd', 'e', 's', 'l', 'e', 'e', 'f', 's', '.']</td>
</tr></table></td></tr>
</table></div>
<p>The objects <tt class="doctest"><span class="pre">len</span></tt> and <tt class="doctest"><span class="pre">last_letter</span></tt> can be
passed around like lists and dictionaries.  Notice that parentheses
are only used after a function name if we are invoking the function;
when we are simply treating the function as an object these are omitted.</p>
<p>Python provides us with one more way to define functions as arguments
to other functions, so-called <a name="lambda_expressions_index_term" /><span class="termdef">lambda expressions</span>.  Supposing there
was no need to use the above <tt class="doctest"><span class="pre">last_letter()</span></tt> function in multiple places,
and thus no need to give it a name.  We can equivalently write the following:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> extract_property(lambda w: w[-1])
['e', 'e', 'f', 'e', 'e', ',', 'd', 'e', 's', 'l', 'e', 'e', 'f', 's', '.']</td>
</tr></table></td></tr>
</table></div>
<p>Our next example illustrates passing a function to the <tt class="doctest"><span class="pre">sorted()</span></tt> function.
When we call the latter with a single argument (the list to be sorted),
it uses the built-in comparison function <tt class="doctest"><span class="pre">cmp()</span></tt>.
However, we can supply our own sort function, e.g. to sort by decreasing
length.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> sorted(sent)
[',', '.', 'Take', 'and', 'care', 'care', 'of', 'of', 'sense', 'sounds',
'take', 'the', 'the', 'themselves', 'will']
>>> sorted(sent, cmp)
[',', '.', 'Take', 'and', 'care', 'care', 'of', 'of', 'sense', 'sounds',
'take', 'the', 'the', 'themselves', 'will']
>>> sorted(sent, lambda x, y: cmp(len(y), len(x)))
['themselves', 'sounds', 'sense', 'Take', 'care', 'will', 'take', 'care',
'the', 'and', 'the', 'of', 'of', ',', '.']</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="accumulative-functions">
<h3>Accumulative Functions</h3>
<p>These functions start by initializing some storage, and iterate over
input to build it up, before returning some final object (a large structure
or aggregated result).  A standard way to do this is to initialize an
empty list, accumulate the material, then return the list, as shown
in function <tt class="doctest"><span class="pre">search1()</span></tt> in <a class="reference internal" href="#code-search-examples">4.5</a>.</p>
<span class="target" id="code-search-examples"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">def search1(substring, words):
    result = []
    for word in words:
        if substring in word:
            result.append(word)
    return result

def search2(substring, words):
    for word in words:
        if substring in word:
            yield word</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> for item in search1('zz', nltk.corpus.brown.words()):
...     print(item, end=" ")
Grizzlies' fizzled Rizzuto huzzahs dazzler jazz Pezza ...
>>> for item in search2('zz', nltk.corpus.brown.words()):
...     print(item, end=" ")
Grizzlies' fizzled Rizzuto huzzahs dazzler jazz Pezza ...</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_search_examples.py" type="text/x-python"><span class="caption-label">Example 4.5 (code_search_examples.py)</span></a>: <span class="caption-label">Figure 4.5</span>: Accumulating Output into a List</td></tr></p>
</table></div>
<p>The function <tt class="doctest"><span class="pre">search2()</span></tt> is a generator.
The first time this function is called, it gets as far as the <tt class="doctest"><span class="pre">yield</span></tt>
statement and pauses.  The calling program gets the first word and does
any necessary processing.  Once the calling program is ready for another
word, execution of the function is continued from where it stopped, until
the next time it encounters a <tt class="doctest"><span class="pre">yield</span></tt> statement.  This approach is
typically more efficient, as the function only generates the data as it is
required by the calling program, and does not need to allocate additional
memory to store the output (cf. our discussion of generator expressions above).</p>
<p>Here's a more sophisticated example of a generator which produces
all permutations of a list of words.  In order to force the <tt class="doctest"><span class="pre">permutations()</span></tt>
function to generate all its output, we wrap it with a call to <tt class="doctest"><span class="pre">list()</span></tt> <a class="reference internal" href="#listperm"><span id="ref-listperm"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def permutations(seq):
...     if len(seq) <= 1:
...         yield seq
...     else:
...         for perm in permutations(seq[1:]):
...             for i in range(len(perm)+1):
...                 yield perm[:i] + seq[0:1] + perm[i:]
...
>>> list(permutations(['police', 'fish', 'buffalo'])) # [_listperm]
[['police', 'fish', 'buffalo'], ['fish', 'police', 'buffalo'],
 ['fish', 'buffalo', 'police'], ['police', 'buffalo', 'fish'],
 ['buffalo', 'police', 'fish'], ['buffalo', 'fish', 'police']]</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="doctest"><span class="pre">permutations</span></tt> function uses a technique called recursion,
discussed below in <a class="reference internal" href="#sec-algorithm-design">4.7</a>.
The ability to generate permutations of a set of words is
useful for creating data to test a grammar (<a href="#id11"><span class="problematic" id="id12">chap-parse_</span></a>).</p>
</div>
</div>
<div class="section" id="higher-order-functions">
<h3>Higher-Order Functions</h3>
<p>Python provides some higher-order functions that are standard
features of functional programming languages such as Haskell.
We illustrate them here, alongside the equivalent expression
using list comprehensions.</p>
<p>Let's start by defining a function <tt class="doctest"><span class="pre">is_content_word()</span></tt>
which checks whether a word is from the open class of content words.
We use this function as the first parameter of <tt class="doctest"><span class="pre">filter()</span></tt>,
which applies the function to each item in the sequence contained
in its second parameter, and only retains the items for which
the function returns <tt class="doctest"><span class="pre">True</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def is_content_word(word):
...     return word.lower() not in ['a', 'of', 'the', 'and', 'will', ',', '.']
>>> sent = ['Take', 'care', 'of', 'the', 'sense', ',', 'and', 'the',
...         'sounds', 'will', 'take', 'care', 'of', 'themselves', '.']
>>> list(filter(is_content_word, sent))
['Take', 'care', 'sense', 'sounds', 'take', 'care', 'themselves']
>>> [w for w in sent if is_content_word(w)]
['Take', 'care', 'sense', 'sounds', 'take', 'care', 'themselves']</td>
</tr></table></td></tr>
</table></div>
<p>Another higher-order function is <tt class="doctest"><span class="pre">map()</span></tt>, which applies a function
to every item in a sequence.  It is a general version of the
<tt class="doctest"><span class="pre">extract_property()</span></tt> function we saw in <a class="reference internal" href="#sec-doing-more-with-functions">4.5</a>.
Here is a simple way to find the average length of a sentence in the news
section of the Brown Corpus, followed by an equivalent version with list comprehension
calculation:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> lengths = list(map(len, nltk.corpus.brown.sents(categories='news')))
>>> sum(lengths) / len(lengths)
21.75081116158339
>>> lengths = [len(sent) for sent in nltk.corpus.brown.sents(categories='news')]
>>> sum(lengths) / len(lengths)
21.75081116158339</td>
</tr></table></td></tr>
</table></div>
<p>In the above examples we specified a user-defined function <tt class="doctest"><span class="pre">is_content_word()</span></tt>
and a built-in function <tt class="doctest"><span class="pre">len()</span></tt>.  We can also provide a lambda expression.
Here's a pair of equivalent examples which count the number of vowels in each word.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> list(map(lambda w: len(filter(lambda c: c.lower() in "aeiou", w)), sent))
[2, 2, 1, 1, 2, 0, 1, 1, 2, 1, 2, 2, 1, 3, 0]
>>> [len(c for c in w if c.lower() in "aeiou") for w in sent]
[2, 2, 1, 1, 2, 0, 1, 1, 2, 1, 2, 2, 1, 3, 0]</td>
</tr></table></td></tr>
</table></div>
<p>The solutions based on list comprehensions are usually more readable than the
solutions based on higher-order functions, and we have favored the former
approach throughout this book.</p>
</div>
<div class="section" id="named-arguments">
<h3>Named Arguments</h3>
<p>When there are a lot of parameters it is easy to get confused about the
correct order.  Instead we can refer to parameters by name, and even assign
them a default value just in case one was not provided by the calling
program.  Now the parameters can be specified in any order, and can be omitted.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def repeat(msg='<empty>', num=1):
...     return msg * num
>>> repeat(num=3)
'<empty><empty><empty>'
>>> repeat(msg='Alice')
'Alice'
>>> repeat(num=5, msg='Alice')
'AliceAliceAliceAliceAlice'</td>
</tr></table></td></tr>
</table></div>
<!-- XXX this is going to be confusing for the novice. I suggest omitting the kwargs** -->
<!-- parameter for simplicity, and referring the reader to the Python Tutorial. -->
<p>These are called <a name="keyword_arguments_index_term" /><span class="termdef">keyword arguments</span>.
If we mix these two kinds of parameters, then we must ensure that the unnamed parameters precede the named ones.
It has to be this way, since unnamed parameters are defined by position.  We can define a function that takes
an arbitrary number of unnamed and named parameters, and access them via an in-place list of arguments <tt class="doctest"><span class="pre">*args</span></tt> and
an &quot;in-place dictionary&quot; of keyword arguments <tt class="doctest"><span class="pre">**kwargs</span></tt>.
(Dictionaries will be presented in <a href="#id13"><span class="problematic" id="id14">sec-dictionaries_</span></a>.)</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def generic(*args, **kwargs):
...     print(args)
...     print(kwargs)
...
>>> generic(1, "African swallow", monty="python")
(1, 'African swallow')
{'monty': 'python'}</td>
</tr></table></td></tr>
</table></div>
<p>When <tt class="doctest"><span class="pre">*args</span></tt> appears as a function parameter, it actually corresponds to all the unnamed parameters of
the function.  Here's another illustration of this aspect of Python syntax, for the <tt class="doctest"><span class="pre">zip()</span></tt> function which
operates on a variable number of arguments.  We'll use the variable name <tt class="doctest"><span class="pre">*song</span></tt> to demonstrate that
there's nothing special about the name <tt class="doctest"><span class="pre">*args</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> song = [['four', 'calling', 'birds'],
...         ['three', 'French', 'hens'],
...         ['two', 'turtle', 'doves']]
>>> list(zip(song[0], song[1], song[2]))
[('four', 'three', 'two'), ('calling', 'French', 'turtle'), ('birds', 'hens', 'doves')]
>>> list(zip(*song))
[('four', 'three', 'two'), ('calling', 'French', 'turtle'), ('birds', 'hens', 'doves')]</td>
</tr></table></td></tr>
</table></div>
<p>It should be clear from the above example that typing <tt class="doctest"><span class="pre">*song</span></tt> is just a convenient
shorthand, and equivalent to typing out <tt class="doctest"><span class="pre">song[0], song[1], song[2]</span></tt>.</p>
<p>Here's another example of the use of keyword arguments in a function
definition, along with three equivalent ways to call the function:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def freq_words(file, min=1, num=10):
...     text = open(file).read()
...     tokens = word_tokenize(text)
...     freqdist = nltk.FreqDist(t for t in tokens if len(t) >= min)
...     return freqdist.most_common(num)
>>> fw = freq_words('ch01.rst', 4, 10)
>>> fw = freq_words('ch01.rst', min=4, num=10)
>>> fw = freq_words('ch01.rst', num=10, min=4)</td>
</tr></table></td></tr>
</table></div>
<p>A side-effect of having named arguments is that they permit optionality.  Thus we
can leave out any arguments where we are happy with the default value:
<tt class="doctest"><span class="pre">freq_words('ch01.rst', min=4)</span></tt>, <tt class="doctest"><span class="pre">freq_words('ch01.rst', 4)</span></tt>.
Another common use of optional arguments is to permit a flag.
Here's a revised version of the same function that reports its
progress if a <tt class="doctest"><span class="pre">verbose</span></tt> flag is set:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def freq_words(file, min=1, num=10, verbose=False):
...     freqdist = FreqDist()
...     if verbose: print("Opening", file)
...     text = open(file).read()
...     if verbose: print("Read in %d characters" % len(file))
...     for word in word_tokenize(text):
...         if len(word) >= min:
...             freqdist[word] += 1
...             if verbose and freqdist.N() % 100 == 0: print(".", sep="")
...     if verbose: print
...     return freqdist.most_common(num)</td>
</tr></table></td></tr>
</table></div>
<div class="admonition caution">
<p class="first admonition-title">Caution!</p>
<p class="last">Take care not to use a mutable object as the default value of
a parameter.  A series of calls to the function will use the
same object, sometimes with bizarre results as we will see in
the discussion of debugging below.</p>
</div>
<div class="admonition caution">
<p class="first admonition-title">Caution!</p>
<p>If your program will work with a lot of files, it is a good idea to
close any open files once they are no longer required. Python will
close open files automatically if you use the <tt class="doctest"><span class="pre">with</span></tt> statement:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> with open("lexicon.txt") as f:
...     data = f.read()
...     # process the data</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
</div>
<div class="section" id="program-development">
<span id="sec-program-development"></span><h2>4.6&nbsp;&nbsp;&nbsp;Program Development</h2>
<p>Programming is a skill that is acquired over several years of
experience with a variety of programming languages and tasks.  Key
high-level abilities are <em>algorithm design</em> and its manifestation in
<em>structured programming</em>.  Key low-level abilities include familiarity
with the syntactic constructs of the language, and knowledge of a
variety of diagnostic methods for trouble-shooting a program which
does not exhibit the expected behavior.</p>
<p>This section describes the internal structure of a program module and
how to organize a multi-module program.  Then it describes various
kinds of error that arise during program development, what you can
do to fix them and, better still, to avoid them in the first place.</p>
<div class="section" id="structure-of-a-python-module">
<h3>Structure of a Python Module</h3>
<p>The purpose of a program module is to bring logically-related definitions and functions
together in order to facilitate re-use and abstraction.  Python modules are nothing
more than individual <tt class="doctest"><span class="pre">.py</span></tt> files.  For example, if you were working
with a particular corpus format, the functions to read and write the format could be
kept together.  Constants used by both formats, such as field separators,
or a <tt class="doctest"><span class="pre">EXTN = ".inf"</span></tt> filename extension, could be shared.  If the format was updated,
you would know that only one file needed to be changed.  Similarly, a module could
contain code for creating and manipulating a particular data structure such as
syntax trees, or code for performing a particular processing task such as
plotting corpus statistics.</p>
<p>When you start writing Python modules, it helps to have some
examples to emulate.  You can locate the code for any NLTK module on your
system using the <tt class="doctest"><span class="pre">__file__</span></tt> variable, e.g.:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> nltk.metrics.distance.__file__
'/usr/lib/python2.5/site-packages/nltk/metrics/distance.pyc'</td>
</tr></table></td></tr>
</table></div>
<p>This returns the location of the compiled <tt class="doctest"><span class="pre">.pyc</span></tt> file for the module, and
you'll probably see a different location on your machine. The file that you will need
to open is the corresponding <tt class="doctest"><span class="pre">.py</span></tt> source file, and this will be in the same
directory as the <tt class="doctest"><span class="pre">.pyc</span></tt> file.
Alternatively, you can view the latest version of this module on the web
at <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/source/browse/trunk/nltk/nltk/metrics/distance.py</span></tt>.</p>
<p>Like every other NLTK module, <tt class="doctest"><span class="pre">distance.py</span></tt> begins with a group of comment
lines giving a one-line title of the module and identifying the authors.
(Since the code is distributed, it also includes the URL where the
code is available, a copyright statement, and license information.)
Next is the module-level docstring, a triple-quoted multiline string
containing information about the module that will be printed when
someone types <tt class="doctest"><span class="pre">help(nltk.metrics.distance)</span></tt>.</p>
<!-- XXX how about putting this in a pylisting?  (didn't work) -->
<pre class="literal-block">
# Natural Language Toolkit: Distance Metrics
#
# Copyright (C) 2001-2013 NLTK Project
# Author: Edward Loper &lt;edloper&#64;gmail.com&gt;
#         Steven Bird &lt;stevenbird1&#64;gmail.com&gt;
#         Tom Lippincott &lt;tom&#64;cs.columbia.edu&gt;
# URL: &lt;http://nltk.org/&gt;
# For license information, see LICENSE.TXT
#

&quot;&quot;&quot;
Distance Metrics.

Compute the distance between two items (usually strings).
As metrics, they must satisfy the following three requirements:

1. d(a, a) = 0
2. d(a, b) &gt;= 0
3. d(a, c) &lt;= d(a, b) + d(b, c)
&quot;&quot;&quot;
</pre>
<p>After this comes all the import statements required for the module,
then any global variables,
followed by a series of function definitions that make up most
of the module.  Other modules define &quot;classes,&quot; the main building block
of object-oriented programming, which falls outside the scope of this book.
(Most NLTK modules also include a <tt class="doctest"><span class="pre">demo()</span></tt> function which can be used
to see examples of the module in use.)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some module variables and functions are only used within the module.
These should have names beginning with an underscore, e.g. <tt class="doctest"><span class="pre">_helper()</span></tt>,
since this will hide the name.  If another module imports this one,
using the idiom: <tt class="doctest"><span class="pre">from module import *</span></tt>, these names will not be imported.
You can optionally list the externally accessible names of a module using
a special built-in variable like this: <tt class="doctest"><span class="pre">__all__ = ['edit_distance', 'jaccard_distance']</span></tt>.</p>
</div>
</div>
<div class="section" id="multi-module-programs">
<h3>Multi-Module Programs</h3>
<p>Some programs bring together a diverse range of tasks, such as loading data from
a corpus, performing some analysis tasks on the data, then visualizing it.
We may already have stable modules that take care of loading data and producing visualizations.
Our work might involve coding up the analysis task, and just invoking functions
from the existing modules.  This scenario is depicted in <a class="reference internal" href="#fig-multi-module">fig-multi-module</a>.</p>
<div class="system-message" id="fig-multi-module">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 1654)</p>
<p>Error in &quot;figure&quot; directive:
invalid option value: (option: &quot;scale&quot;; value: '20:50:30')
invalid literal for int() with base 10: '20:50:30'.</p>
<pre class="literal-block">
.. figure:: ../images/multi-module.png
   :scale: 20:50:30

   Structure of a Multi-Module Program: The main program ``my_program.py`` imports functions
   from two other modules; unique analysis tasks are localized to the main program, while
   common loading and visualization tasks are kept apart to facilitate re-use and abstraction.

</pre>
</div>
<p>By dividing our work into several modules and using <tt class="doctest"><span class="pre">import</span></tt> statements to
access functions defined elsewhere, we can keep the individual modules simple
and easy to maintain.  This approach will also result in a growing collection
of modules, and make it possible for us to build sophisticated systems involving
a hierarchy of modules.  Designing such systems well is a
complex software engineering task, and beyond the scope of this book.</p>
</div>
<div class="section" id="sources-of-error">
<h3>Sources of Error</h3>
<p>Mastery of programming depends on having a variety of problem-solving skills to
draw upon when the program doesn't work as expected.  Something as trivial as
a mis-placed symbol might cause the program to behave very differently.
We call these &quot;bugs&quot; because they are tiny in comparison to the damage
they can cause.  They creep into our code unnoticed, and it's only much later
when we're running the program on some new data that their presence is detected.
Sometimes, fixing one bug only reveals another, and we get the distinct impression
that the bug is on the move.  The only reassurance we have is that bugs are
spontaneous and not the fault of the programmer.</p>
<p>Flippancy aside, debugging code is hard because there are so many ways for
it to be faulty.  Our understanding of the input data, the algorithm, or
even the programming language, may be at fault.  Let's look at examples
of each of these.</p>
<p>First, the input data may contain some unexpected characters.
For example, WordNet synset names have the form <tt class="doctest"><span class="pre">tree.n.01</span></tt>, with three
components separated using periods.  The NLTK WordNet module initially
decomposed these names using <tt class="doctest"><span class="pre">split('.')</span></tt>.  However, this method broke when
someone tried to look up the word <span class="example">PhD</span>, which has the synset
name <tt class="doctest"><span class="pre">ph.d..n.01</span></tt>, containing four periods instead of the expected two.
The solution was to use <tt class="doctest"><span class="pre">rsplit('.', 2)</span></tt> to do at most two splits, using
the rightmost instances of the period, and leaving the <tt class="doctest"><span class="pre">ph.d.</span></tt> string intact.
Although several people had tested
the module before it was released, it was some weeks before someone detected
the problem (see <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/issues/detail?id=297</span></tt>).</p>
<p>Second, a supplied function might not behave as expected.
For example, while testing NLTK's interface to WordNet, one of the
authors noticed that no synsets had any antonyms defined, even though
the underlying database provided a large quantity of antonym information.
What looked like a bug in the WordNet interface turned out to
be a misunderstanding about WordNet itself: antonyms are defined for
lemmas, not for synsets.  The only &quot;bug&quot; was a misunderstanding
of the interface (see <tt class="doctest"><span class="pre">http://code.google.com/p/nltk/issues/detail?id=98</span></tt>).</p>
<!-- XXX much easier to get the point of the next example if it is on a single line, so -->
<!-- a doctest block would work better -->
<p>Third, our understanding of Python's semantics may be at fault.
It is easy to make the wrong assumption about the relative
scope of two operators.
For example, <tt class="doctest"><span class="pre">"%s.%s.%02d" % "ph.d.", "n", 1</span></tt> produces a run-time
error <tt class="doctest"><span class="pre">TypeError: not enough arguments for format string</span></tt>.
This is because the percent operator has higher precedence than
the comma operator.  The fix is to add parentheses in order to
force the required scope.  As another example, suppose we are
defining a function to collect all tokens of a text having a
given length.  The function has parameters for the text and
the word length, and an extra parameter that allows the initial
value of the result to be given as a parameter:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def find_words(text, wordlength, result=[]):
...     for word in text:
...         if len(word) == wordlength:
...             result.append(word)
...     return result
>>> find_words(['omg', 'teh', 'lolcat', 'sitted', 'on', 'teh', 'mat'], 3) # [_find-words-1]
['omg', 'teh', 'teh', 'mat']
>>> find_words(['omg', 'teh', 'lolcat', 'sitted', 'on', 'teh', 'mat'], 2, ['ur']) # [_find-words-2]
['ur', 'on']
>>> find_words(['omg', 'teh', 'lolcat', 'sitted', 'on', 'teh', 'mat'], 3) # [_find-words-3]
['omg', 'teh', 'teh', 'mat', 'omg', 'teh', 'teh', 'mat']</td>
</tr></table></td></tr>
</table></div>
<p>The first time we call <tt class="doctest"><span class="pre">find_words()</span></tt> <a class="reference internal" href="#find-words-1"><span id="ref-find-words-1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, we get all three-letter
words as expected.  The second time we specify an initial value for the result,
a one-element list <tt class="doctest"><span class="pre">['ur']</span></tt>, and as expected, the result has this word along with the
other two-letter word in our text.  Now, the next time we call <tt class="doctest"><span class="pre">find_words()</span></tt> <a class="reference internal" href="#find-words-3"><span id="ref-find-words-3"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>
we use the same parameters as in <a class="reference internal" href="#find-words-1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>, but we get a different result!
Each time we call <tt class="doctest"><span class="pre">find_words()</span></tt> with no third parameter, the result will
simply extend the result of the previous call, rather than start with the
empty result list as specified in the function definition.  The program's
behavior is not as expected because we incorrectly assumed that the default
value was created at the time the function was invoked.  However, it is
created just once, at the time the Python interpreter loads the function.
This one list object is used whenever no explicit value is provided to the function.</p>
</div>
<div class="section" id="debugging-techniques">
<h3>Debugging Techniques</h3>
<p>Since most code errors result from the programmer making incorrect assumptions,
the first thing to do when you detect a bug is to <span class="emphasis">check your assumptions</span>.
Localize the problem by adding <tt class="doctest"><span class="pre">print</span></tt> statements to the program, showing the
value of important variables, and showing how far the program has progressed.</p>
<p>If the program produced an &quot;exception&quot; &#8212; a run-time error &#8212;
the interpreter will print a <a name="stack_trace_index_term" /><span class="termdef">stack trace</span>,
pinpointing the location of program execution at the time of the error.
If the program depends on input data, try to reduce this to the smallest
size while still producing the error.</p>
<p>Once you have localized the problem to a particular function, or to a line
of code, you need to work out what is going wrong.  It is often helpful to
recreate the situation using the interactive command line.  Define some
variables then copy-paste the offending line of code into the session
and see what happens.  Check your understanding of the code by reading
some documentation, and examining other code samples that purport to do
the same thing that you are trying to do.  Try explaining your code to
someone else, in case they can see where things are going wrong.</p>
<p>Python provides a <a name="debugger_index_term" /><span class="termdef">debugger</span> which allows you to monitor the execution
of your program, specify line numbers where execution will stop (i.e. <a name="breakpoints_index_term" /><span class="termdef">breakpoints</span>),
and step through sections of code and inspect the value of variables.
You can invoke the debugger on your code as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> import pdb
>>> import mymodule
>>> pdb.run('mymodule.myfunction()')</td>
</tr></table></td></tr>
</table></div>
<p>It will present you with a prompt <tt class="doctest"><span class="pre">(Pdb)</span></tt> where you can type instructions
to the debugger.  Type <tt class="doctest"><span class="pre">help</span></tt> to see the full list of commands.
Typing <tt class="doctest"><span class="pre">step</span></tt> (or just <tt class="doctest"><span class="pre">s</span></tt>) will execute the current line and
stop.  If the current line calls a function, it will enter the function
and stop at the first line.  Typing <tt class="doctest"><span class="pre">next</span></tt> (or just <tt class="doctest"><span class="pre">n</span></tt>) is similar,
but it stops execution at the next line in the current function.  The
<tt class="doctest"><span class="pre">break</span></tt> (or <tt class="doctest"><span class="pre">b</span></tt>) command can be used to create or list breakpoints.  Type
<tt class="doctest"><span class="pre">continue</span></tt> (or <tt class="doctest"><span class="pre">c</span></tt>) to continue execution as far as the next breakpoint.
Type the name of any variable to inspect its value.</p>
<p>We can use the Python debugger to locate the problem in our <tt class="doctest"><span class="pre">find_words()</span></tt>
function.  Remember that the problem arose the second time the function was
called.  We'll start by calling the function without using the debugger <a href="#id15"><span class="problematic" id="id16">first-run_</span></a>,
using the smallest possible input.  The second time, we'll call it with the
debugger <a href="#id17"><span class="problematic" id="id18">second-run_</span></a>.
.. doctest-ignore:</p>
<pre class="literal-block">
&gt;&gt;&gt; import pdb
&gt;&gt;&gt; find_words(['cat'], 3) # [_first-run]
['cat']
&gt;&gt;&gt; pdb.run(&quot;find_words(['dog'], 3)&quot;) # [_second-run]
&gt; &lt;string&gt;(1)&lt;module&gt;()
(Pdb) step
--Call--
&gt; &lt;stdin&gt;(1)find_words()
(Pdb) args
text = ['dog']
wordlength = 3
result = ['cat']
</pre>
<p>Here we typed just two commands into the debugger: <tt class="doctest"><span class="pre">step</span></tt> took us inside
the function, and <tt class="doctest"><span class="pre">args</span></tt> showed the values of its arguments (or parameters).
We see immediately that <tt class="doctest"><span class="pre">result</span></tt> has an initial value of <tt class="doctest"><span class="pre">['cat']</span></tt>, and not
the empty list as expected.  The debugger has helped us to localize the problem,
prompting us to check our understanding of Python functions.</p>
</div>
<div class="section" id="defensive-programming">
<h3>Defensive Programming</h3>
<p>In order to avoid some of the pain of debugging, it helps to adopt
some defensive programming habits.  Instead of writing a 20-line
program then testing it, build the program bottom-up out of
small pieces that are known to work.  Each time you combine these
pieces to make a larger unit, test it carefully to see that it works
as expected.  Consider adding <tt class="doctest"><span class="pre">assert</span></tt> statements to your code,
specifying properties of a variable, e.g. <tt class="doctest"><span class="pre">assert(isinstance(text, list))</span></tt>.
If the value of the <tt class="doctest"><span class="pre">text</span></tt> variable later becomes a string when your
code is used in some larger context, this will raise an <tt class="doctest"><span class="pre">AssertionError</span></tt>
and you will get immediate notification of the problem.</p>
<p>Once you think you've found the bug, view your solution as a hypothesis.
Try to predict the effect of your bugfix before re-running the program.
If the bug isn't fixed, don't fall into the trap of blindly changing
the code in the hope that it will magically start working again.
Instead, for each change, try to articulate a hypothesis about what
is wrong and why the change will fix the problem.  Then undo the change
if the problem was not resolved.</p>
<p>As you develop your program, extend its functionality, and fix any bugs,
it helps to maintain a suite of test cases.
This is called <a name="regression_testing_index_term" /><span class="termdef">regression testing</span>, since it is meant to detect
situations where the code &quot;regresses&quot; &#8212; where a change to the
code has an unintended side-effect of breaking something that
used to work.  Python provides a simple regression testing framework
in the form of the <tt class="doctest"><span class="pre">doctest</span></tt> module.  This module searches a file
of code or documentation for blocks of text that look like
an interactive Python session, of the form you have already seen
many times in this book.  It executes the Python commands it finds,
and tests that their output matches the output supplied in the original
file.  Whenever there is a mismatch, it reports the expected and actual
values.  For details please consult the <tt class="doctest"><span class="pre">doctest</span></tt> documentation at
<tt class="doctest"><span class="pre">http://docs.python.org/library/doctest.html</span></tt>.  Apart from its
value for regression testing, the <tt class="doctest"><span class="pre">doctest</span></tt> module is useful for
ensuring that your software documentation stays in sync with your
code.</p>
<p>Perhaps the most important defensive programming strategy is to
set out your code clearly, choose meaningful variable and function
names, and simplify the code wherever possible by decomposing it into
functions and modules with well-documented interfaces.</p>
</div>
</div>
<div class="section" id="algorithm-design">
<span id="sec-algorithm-design"></span><h2>4.7&nbsp;&nbsp;&nbsp;Algorithm Design</h2>
<p>This section discusses more advanced concepts, which you may prefer to skip on the
first time through this chapter.</p>
<p>A major part of algorithmic problem solving is selecting or adapting
an appropriate algorithm for the problem at hand.  Sometimes there are
several alternatives, and choosing the best one depends on knowledge
about how each alternative performs as the size of the data grows.
Whole books are written on this topic, and we only have space to introduce
some key concepts and elaborate on the approaches that are most prevalent
in natural language processing.</p>
<p>The best known strategy is known as <a name="divide_and_conquer_index_term" /><span class="termdef">divide-and-conquer</span>.
We attack a problem of size <em>n</em> by dividing it into two problems of size <em>n/2</em>,
solve these problems, and combine their results into a solution of the original problem.
For example, suppose that we had a pile of cards with a single word written on each card.
We could sort this pile by splitting it in half and giving it to two other people
to sort (they could do the same in turn).  Then, when two sorted piles come back, it
is an easy task to merge them into a single sorted pile.
See <a class="reference internal" href="#fig-mergesort">4.6</a> for an illustration of this process.</p>
<span class="target" id="fig-mergesort"></span><div class="figure" id="fig-mergesort">
<img alt="../images/mergesort.png" src="../images/mergesort.png" />
<p class="caption"><span class="caption-label">Figure 4.6</span>: Sorting by Divide-and-Conquer: to sort an array, we split it in half and
sort each half (recursively); we merge each sorted half back into a whole
list (again recursively); this algorithm is known as &quot;Merge Sort&quot;.</p>
</div>
<p>Another example is the process of looking up a word in a dictionary.  We open
the book somewhere around the middle and compare our word with the current
page.  If it's earlier in the dictionary we repeat the process on the first
half; if its later we use the second half.  This search method is called
<span class="example">binary search</span> since it splits the problem in half at every step.</p>
<p>In another approach to algorithm design, we attack a problem
by transforming it into an instance of a problem we already know how to solve.
For example, in order to detect duplicate entries in a list, we can <a name="pre_sort_index_term" /><span class="termdef">pre-sort</span>
the list, then scan through it once to check if any adjacent pairs of elements
are identical.</p>
<div class="section" id="recursion">
<h3>Recursion</h3>
<p>The above examples of sorting and searching have a striking property:
to solve a problem of size <span class="math">n</span>, we have to break it in half and
then work on one or more problems of size <span class="math">n/2</span>.
A common way to implement such methods uses <a name="recursion_index_term" /><span class="termdef">recursion</span>.
We define a function <span class="math">f</span> which simplifies the problem,
and <span class="emphasis">calls itself</span> to solve one or more easier instances
of the same problem.  It then combines the results into a solution
for the original problem.</p>
<p>For example, suppose we have a set of <span class="math">n</span> words, and want to
calculate how many different ways they can be combined to make a
sequence of words.  If we have only one word (<span class="math">n=1</span>), there is
just one way to make it into a sequence.  If we have a set of two
words, there are two ways to put them into a sequence.  For three
words there are six possibilities.  In general, for <span class="math">n</span> words,
there are <span class="math">n</span> &#215; <span class="math">n</span>-1 &#215; &#8230; &#215; 2 &#215; 1
ways (i.e. the factorial of <span class="math">n</span>).  We can code this up as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def factorial1(n):
...     result = 1
...     for i in range(n):
...         result *= (i+1)
...     return result</td>
</tr></table></td></tr>
</table></div>
<p>However, there is also a recursive algorithm for solving this problem,
based on the following observation.  Suppose we have a way to
construct all orderings for <span class="math">n</span>-1 distinct words.  Then
for each such ordering, there are <span class="math">n</span> places where we can
insert a new word: at the start, the end, or any of the <span class="math">n</span>-2
boundaries between the words.  Thus we simply multiply the number
of solutions found for <span class="math">n</span>-1 by the value of <span class="math">n</span>.
We also need the <a name="base_case_index_term" /><span class="termdef">base case</span>, to say that if we have a single
word, there's just one ordering.  We can code this up as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def factorial2(n):
...     if n == 1:
...         return 1
...     else:
...         return n * factorial2(n-1)</td>
</tr></table></td></tr>
</table></div>
<!-- XXX clarify that size != depth here -->
<p>These two algorithms solve the same problem.  One uses iteration
while the other uses recursion.
We can use recursion to navigate a deeply-nested object, such as the
WordNet hypernym hierarchy.  Let's count the size of the hypernym
hierarchy rooted at a given synset <span class="math">s</span>.  We'll do this by finding the
size of each hyponym of <span class="math">s</span>, then adding these together
(we will also add 1 for the synset itself).  The following
function <tt class="doctest"><span class="pre">size1()</span></tt> does this work; notice that the body of
the function includes a recursive call to <tt class="doctest"><span class="pre">size1()</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def size1(s):
...     return 1 + sum(size1(child) for child in s.hyponyms())</td>
</tr></table></td></tr>
</table></div>
<p>We can also design an iterative solution to this problem which processes
the hierarchy in layers.  The first layer is the synset itself <a class="reference internal" href="#first-layer"><span id="ref-first-layer"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
then all the hyponyms of the synset, then all the hyponyms of the
hyponyms.  Each time through the loop it computes the next layer
by finding the hyponyms of everything in the last layer <a class="reference internal" href="#update-layer"><span id="ref-update-layer"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.
It also maintains a total of the number of synsets encountered so far <a class="reference internal" href="#update-total"><span id="ref-update-total"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> def size2(s):
...     layer = [s] # [_first-layer]
...     total = 0
...     while layer:
...         total += len(layer) # [_update-total]
...         layer = [h for c in layer for h in c.hyponyms()] # [_update-layer]
...     return total</td>
</tr></table></td></tr>
</table></div>
<p>Not only is the iterative solution much longer, it is harder to interpret.
It forces us to think procedurally, and keep track of what is happening with
the <tt class="doctest"><span class="pre">layer</span></tt> and <tt class="doctest"><span class="pre">total</span></tt> variables through time.  Let's satisfy ourselves
that both solutions give the same result.  We'll use another form of the import
statement, allowing us to abbreviate the name <tt class="doctest"><span class="pre">wordnet</span></tt> to <tt class="doctest"><span class="pre">wn</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> from nltk.corpus import wordnet as wn
>>> dog = wn.synset('dog.n.01')
>>> size1(dog)
190
>>> size2(dog)
190</td>
</tr></table></td></tr>
</table></div>
<p>As a final example of recursion, let's use it to <span class="emphasis">construct</span>
a deeply-nested object.
A <a name="letter_trie_index_term" /><span class="termdef">letter trie</span> is a data structure that can be used
for indexing a lexicon, one letter at a time.  (The name
is based on the word re<span class="emphasis">trie</span>val).
For example, if <tt class="doctest"><span class="pre">trie</span></tt>
contained a letter trie, then <tt class="doctest"><span class="pre">trie['c']</span></tt> would be a smaller
trie which held all words starting with <span class="example">c</span>.
<a class="reference internal" href="#code-trie">4.7</a> demonstrates the recursive process of building a trie,
using Python dictionaries (<a href="#id19"><span class="problematic" id="id20">sec-dictionaries_</span></a>).
To insert the word <span class="example">chien</span> (French for <span class="example">dog</span>),
we split off the <span class="example">c</span> and recursively insert <span class="example">hien</span>
into the sub-trie <tt class="doctest"><span class="pre">trie['c']</span></tt>.  The recursion continues
until there are no letters remaining in the word, when we
store the intended value (in this case, the word <span class="example">dog</span>).</p>
<span class="target" id="code-trie"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">def insert(trie, key, value):
    if key:
        first, rest = key[0], key[1:]
        if first not in trie:
            trie[first] = {}
        insert(trie[first], rest, value)
    else:
        trie['value'] = value</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> trie = {}
>>> insert(trie, 'chat', 'cat')
>>> insert(trie, 'chien', 'dog')
>>> insert(trie, 'chair', 'flesh')
>>> insert(trie, 'chic', 'stylish')
>>> trie = dict(trie)               # for nicer printing
>>> trie['c']['h']['a']['t']['value']
'cat'
>>> pprint.pprint(trie, width=40)
{'c': {'h': {'a': {'t': {'value': 'cat'}},
                  {'i': {'r': {'value': 'flesh'}}},
             'i': {'e': {'n': {'value': 'dog'}}}
                  {'c': {'value': 'stylish'}}}}}</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_trie.py" type="text/x-python"><span class="caption-label">Example 4.7 (code_trie.py)</span></a>: <span class="caption-label">Figure 4.7</span>: Building a Letter Trie: A recursive function that builds a nested dictionary
structure; each level of nesting contains all words with a given prefix,
and a sub-trie containing all possible continuations.</td></tr></p>
</table></div>
<div class="admonition caution">
<p class="first admonition-title">Caution!</p>
<p class="last">Despite the simplicity of recursive programming, it comes with a cost.
Each time a function is called, some state information needs to be
pushed on a stack, so that once the function has completed, execution
can continue from where it left off.  For this reason, iterative
solutions are often more efficient than recursive solutions.</p>
</div>
</div>
<div class="section" id="space-time-tradeoffs">
<h3>Space-Time Tradeoffs</h3>
<p>We can sometimes significantly speed up the execution of a program by building an auxiliary
data structure, such as an index.  The listing in <a class="reference internal" href="#code-search-documents">4.8</a> implements a simple
text retrieval system for the Movie Reviews Corpus.  By indexing the document collection it
provides much faster lookup.</p>
<span class="target" id="code-search-documents"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">def raw(file):
    contents = open(file).read()
    contents = re.sub(r'<.*?>', ' ', contents)
    contents = re.sub('\s+', ' ', contents)
    return contents

def snippet(doc, term):
    text = ' '*30 + raw(doc) + ' '*30
    pos = text.index(term)
    return text[pos-30:pos+30]

print("Building Index...")
files = nltk.corpus.movie_reviews.abspaths()
idx = nltk.Index((w, f) for f in files for w in raw(f).split())

query = ''
while query != "quit":
    query = input("query> ")     # use raw_input() in Python 2
    if query in idx:
        for doc in idx[query]:
            print(snippet(doc, query))
    else:
        print("Not found")</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_search_documents.py" type="text/x-python"><span class="caption-label">Example 4.8 (code_search_documents.py)</span></a>: <span class="caption-label">Figure 4.8</span>: A Simple Text Retrieval System</td></tr></p>
</table></div>
<p>A more subtle example of a space-time tradeoff involves replacing the tokens of a corpus
with integer identifiers.  We create a vocabulary for the corpus, a list in which each
word is stored once, then invert this list so that we can look up any word to find its
identifier.  Each document is preprocessed, so that a list of words becomes a list of integers.
Any language models can now work with integers.  See the listing in <a class="reference internal" href="#code-strings-to-ints">4.9</a>
for an example of how to do this for a tagged corpus.</p>
<!-- XXX further discussion and performance comparison. -->
<span class="target" id="code-strings-to-ints"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">def preprocess(tagged_corpus):
    words = set()
    tags = set()
    for sent in tagged_corpus:
        for word, tag in sent:
            words.add(word)
            tags.add(tag)
    wm = dict((w, i) for (i, w) in enumerate(words))
    tm = dict((t, i) for (i, t) in enumerate(tags))
    return [[(wm[w], tm[t]) for (w, t) in sent] for sent in tagged_corpus]</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_strings_to_ints.py" type="text/x-python"><span class="caption-label">Example 4.9 (code_strings_to_ints.py)</span></a>: <span class="caption-label">Figure 4.9</span>: Preprocess tagged corpus data, converting all words and tags to integers</td></tr></p>
</table></div>
<p>Another example of a space-time tradeoff is maintaining a vocabulary list.
If you need to process an input text to check that all words are in an
existing vocabulary, the vocabulary should be stored as a set, not a list.
The elements of a set are automatically indexed, so testing membership
of a large set will be much faster than testing membership of the
corresponding list.</p>
<p>We can test this claim using the <tt class="doctest"><span class="pre">timeit</span></tt> module.
The <tt class="doctest"><span class="pre">Timer</span></tt> class has two parameters, a statement which
is executed multiple times, and setup code that is executed
once at the beginning.  We will simulate a vocabulary of
100,000 items using a list <a class="reference internal" href="#vocab-list"><span id="ref-vocab-list"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> or set <a class="reference internal" href="#vocab-set"><span id="ref-vocab-set"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>
of integers.  The test statement will generate a random
item which has a 50% chance of being in the vocabulary <a class="reference internal" href="#vocab-statement"><span id="ref-vocab-statement"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> from timeit import Timer
>>> vocab_size = 100000
>>> setup_list = "import random; vocab = range(%d)" % vocab_size # [_vocab-list]
>>> setup_set = "import random; vocab = set(range(%d))" % vocab_size # [_vocab-set]
>>> statement = "random.randint(0, %d) in vocab" % (vocab_size * 2) # [_vocab-statement]
>>> print(Timer(statement, setup_list).timeit(1000))
2.78092288971
>>> print(Timer(statement, setup_set).timeit(1000))
0.0037260055542</td>
</tr></table></td></tr>
</table></div>
<p>Performing 1000 list membership tests takes a total of 2.8 seconds,
while the equivalent tests on a set take a mere 0.0037 seconds,
or three orders of magnitude faster!</p>
</div>
<div class="section" id="dynamic-programming">
<h3>Dynamic Programming</h3>
<p>Dynamic programming is a general technique for designing algorithms
which is widely used in natural language processing.  The term
'programming' is used in a different sense to what you might expect,
to mean planning or scheduling.  Dynamic programming is used when a
problem contains overlapping sub-problems.  Instead of computing
solutions to these sub-problems repeatedly, we simply store them in a
lookup table.
In the remainder of this section we will introduce dynamic programming,
but in a rather different context to syntactic parsing.</p>
<p>Pingala was an Indian author who lived around the 5th century B.C.,
and wrote a treatise on Sanskrit prosody called the <em>Chandas Shastra</em>.
Virahanka extended this work around the 6th century A.D., studying the
number of ways of combining short and long syllables to create a meter
of length <em>n</em>.  Short syllables, marked <em>S</em>, take up one unit of length, while
long syllables, marked <em>L</em>, take two.
Pingala found, for example, that there are five ways to
construct a meter of length 4: <em>V</em><sub>4</sub> = <em>{LL, SSL, SLS,
LSS, SSSS}</em>.  Observe that we can split <em>V</em><sub>4</sub> into two
subsets, those starting with <em>L</em> and those starting with
<em>S</em>, as shown in <a class="reference internal" href="#ex-v4">(1)</a>.</p>
<span class="target" id="ex-v4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(1)</td><td width="15"></td><td><pre class="literal-block">
<em>V</em><span class="subscript">4</span> =
  LL, LSS
    i.e. L prefixed to each item of <em>V</em><span class="subscript">2</span> = {L, SS}
  SSL, SLS, SSSS
    i.e. S prefixed to each item of <em>V</em><span class="subscript">3</span> = {SL, LS, SSS}
</pre>
</td></tr></table></p>
<span class="target" id="code-virahanka"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">def virahanka1(n):
    if n == 0:
        return [""]
    elif n == 1:
        return ["S"]
    else:
        s = ["S" + prosody for prosody in virahanka1(n-1)]
        l = ["L" + prosody for prosody in virahanka1(n-2)]
        return s + l

def virahanka2(n):
    lookup = [[""], ["S"]]
    for i in range(n-1):
        s = ["S" + prosody for prosody in lookup[i+1]]
        l = ["L" + prosody for prosody in lookup[i]]
        lookup.append(s + l)
    return lookup[n]

def virahanka3(n, lookup={0:[""], 1:["S"]}):
    if n not in lookup:
        s = ["S" + prosody for prosody in virahanka3(n-1)]
        l = ["L" + prosody for prosody in virahanka3(n-2)]
        lookup[n] = s + l
    return lookup[n]

from nltk import memoize
@memoize
def virahanka4(n):
    if n == 0:
        return [""]
    elif n == 1:
        return ["S"]
    else:
        s = ["S" + prosody for prosody in virahanka4(n-1)]
        l = ["L" + prosody for prosody in virahanka4(n-2)]
        return s + l</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> virahanka1(4)
['SSSS', 'SSL', 'SLS', 'LSS', 'LL']
>>> virahanka2(4)
['SSSS', 'SSL', 'SLS', 'LSS', 'LL']
>>> virahanka3(4)
['SSSS', 'SSL', 'SLS', 'LSS', 'LL']
>>> virahanka4(4)
['SSSS', 'SSL', 'SLS', 'LSS', 'LL']</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_virahanka.py" type="text/x-python"><span class="caption-label">Example 4.10 (code_virahanka.py)</span></a>: <span class="caption-label">Figure 4.10</span>: Four Ways to Compute Sanskrit Meter: (i) recursive; (ii) bottom-up dynamic programming;
(iii) top-down dynamic programming; and (iv) built-in memoization.</td></tr></p>
</table></div>
<p>With this observation, we can write a little recursive function called
<tt class="doctest"><span class="pre">virahanka1()</span></tt> to compute these meters, shown in <a class="reference internal" href="#code-virahanka">4.10</a>.
Notice that, in order to compute <em>V</em><sub>4</sub> we first compute
<em>V</em><sub>3</sub> and <em>V</em><sub>2</sub>.  But to compute <em>V</em><sub>3</sub>,
we need to first compute <em>V</em><sub>2</sub> and <em>V</em><sub>1</sub>.  This <a name="call_structure_index_term" /><span class="termdef">call
structure</span> is depicted in <a class="reference internal" href="#ex-call-structure">(2)</a>.</p>
<span class="target" id="ex-call-structure"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(2)</td><td width="15"></td><td><img alt="tree_images/None-tree-12.png" class="align-top" src="tree_images/None-tree-12.png" /></td></tr></table></p>
<p>As you can see, <em>V</em><sub>2</sub> is computed twice.
This might not seem like a significant problem, but
it turns out to be rather wasteful as <em>n</em> gets large:
to compute <em>V</em><sub>20</sub> using this recursive technique, we
would compute <em>V</em><sub>2</sub> 4,181 times;
and for <em>V</em><sub>40</sub> we would compute <em>V</em><sub>2</sub> 63,245,986 times!
A much better alternative is to store the value of <em>V</em><sub>2</sub> in a table
and look it up whenever we need it.  The same goes for other values, such
as <em>V</em><sub>3</sub> and so on.  Function <tt class="doctest"><span class="pre">virahanka2()</span></tt> implements a
dynamic programming approach to the problem.  It works by filling up a
table (called <tt class="doctest"><span class="pre">lookup</span></tt>) with solutions to <em>all</em> smaller instances of the
problem, stopping as soon as we reach the value we're interested in.
At this point we read off the value and return it.  Crucially, each
sub-problem is only ever solved once.</p>
<p>Notice that the approach taken in <tt class="doctest"><span class="pre">virahanka2()</span></tt> is to solve smaller
problems on the way to solving larger problems.  Accordingly, this is known as the
<a name="bottom_up_index_term" /><span class="termdef">bottom-up</span> approach to dynamic programming.  Unfortunately it turns out
to be quite wasteful for some applications, since it
may compute solutions to sub-problems that are never required for
solving the main problem.  This wasted computation can be avoided
using the <a name="top_down_index_term" /><span class="termdef">top-down</span> approach to dynamic programming, which is
illustrated in the function <tt class="doctest"><span class="pre">virahanka3()</span></tt> in <a class="reference internal" href="#code-virahanka">4.10</a>.
Unlike the bottom-up approach, this approach is recursive.  It avoids
the huge wastage of <tt class="doctest"><span class="pre">virahanka1()</span></tt> by checking whether it has
previously stored the result.  If not, it computes the result
recursively and stores it in the table.  The last step is to return
the stored result.  The final method, in <tt class="doctest"><span class="pre">virahanka4()</span></tt>,
is to use a Python &quot;decorator&quot; called <tt class="doctest"><span class="pre">memoize</span></tt>,
which takes care of the housekeeping work done
by <tt class="doctest"><span class="pre">virahanka3()</span></tt> without cluttering up the program.
This &quot;memoization&quot; process stores the result of each previous
call to the function along with the parameters that were used.
If the function is subsequently called with the same parameters,
it returns the stored result instead of recalculating it.
(This aspect of Python syntax is beyond the scope of this book.)</p>
<p>This concludes our brief introduction to dynamic programming.
We will encounter it again in <a href="#id21"><span class="problematic" id="id22">sec-parsing_</span></a>.</p>
</div>
</div>
<div class="section" id="a-sample-of-python-libraries">
<span id="sec-libraries"></span><h2>4.8&nbsp;&nbsp;&nbsp;A Sample of Python Libraries</h2>
<p>Python has hundreds of third-party libraries, specialized software packages that extend
the functionality of Python.  NLTK is one such library.  To realize the full power
of Python programming, you should become familiar with several other libraries.
Most of these will need to be manually installed on your computer.</p>
<div class="section" id="matplotlib">
<h3>Matplotlib</h3>
<p>Python has some libraries that are useful for visualizing language data.
The Matplotlib package supports sophisticated
plotting functions with a MATLAB-style interface, and is available from
<tt class="doctest"><span class="pre">http://matplotlib.sourceforge.net/</span></tt>.</p>
<p>So far we have focused on textual presentation and the use of formatted print
statements to get output lined up in columns.  It is often very useful to display
numerical data in graphical form, since this often makes it easier to detect
patterns.  For example, in <a href="#id23"><span class="problematic" id="id24">code-modal-tabulate_</span></a> we saw a table of numbers
showing the frequency of particular modal verbs in the Brown Corpus, classified
by genre.  The program in <a class="reference internal" href="#code-modal-plot">4.11</a> presents the same information in graphical
format.  The output is shown in <a class="reference internal" href="#fig-modal-genre">4.12</a> (a color figure in the graphical display).</p>
<span class="target" id="code-modal-plot"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">from numpy import arange
from matplotlib import pyplot

colors = 'rgbcmyk' # red, green, blue, cyan, magenta, yellow, black

def bar_chart(categories, words, counts):
    "Plot a bar chart showing counts for each word by category"
    ind = arange(len(words))
    width = 1 / (len(categories) + 1)
    bar_groups = []
    for c in range(len(categories)):
        bars = pyplot.bar(ind+c*width, counts[categories[c]], width,
                         color=colors[c % len(colors)])
        bar_groups.append(bars)
    pyplot.xticks(ind+width, words)
    pyplot.legend([b[0] for b in bar_groups], categories, loc='upper left')
    pyplot.ylabel('Frequency')
    pyplot.title('Frequency of Six Modal Verbs by Genre')
    pyplot.show()</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> genres = ['news', 'religion', 'hobbies', 'government', 'adventure']
>>> modals = ['can', 'could', 'may', 'might', 'must', 'will']
>>> cfdist = nltk.ConditionalFreqDist(
...              (genre, word)
...              for genre in genres
...              for word in nltk.corpus.brown.words(categories=genre)
...              if word in modals)
...
>>> counts = {}
>>> for genre in genres:
...     counts[genre] = [cfdist[genre][word] for word in modals]
>>> bar_chart(genres, modals, counts)</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_modal_plot.py" type="text/x-python"><span class="caption-label">Example 4.11 (code_modal_plot.py)</span></a>: <span class="caption-label">Figure 4.11</span>: Frequency of Modals in Different Sections of the Brown Corpus</td></tr></p>
</table></div>
<span class="target" id="fig-modal-genre"></span><div class="figure" id="fig-modal-genre">
<img alt="../images/modal_genre.png" src="../images/modal_genre.png" />
<p class="caption"><span class="caption-label">Figure 4.12</span>: Bar Chart Showing Frequency of Modals in Different Sections of Brown Corpus: this
visualization was produced by the program in <a class="reference internal" href="#code-modal-plot">4.11</a>.</p>
</div>
<!-- def count_words_by_tag(t, genres):
    cfdist = nltk.ConditionalFreqDist()
    for genre in genres:
        for (word,tag) in nltk.corpus.brown.tagged_words(categories=genre):
            if tag == t:
                 cfdist[genre][word.lower()] += 1
    return cfdist -->
<p>From the bar chart it is immediately obvious that <span class="example">may</span> and <span class="example">must</span> have
almost identical relative frequencies.  The same goes for <span class="example">could</span> and <span class="example">might</span>.</p>
<p>It is also possible to generate such data visualizations on the fly.
For example, a web page with form input could permit visitors to specify
search parameters, submit the form, and see a dynamically generated
visualization.
To do this we have to specify the <tt class="doctest"><span class="pre">Agg</span></tt> backend for <tt class="doctest"><span class="pre">matplotlib</span></tt>,
which is a library for producing raster (pixel) images <a class="reference internal" href="#agg-backend"><span id="ref-agg-backend"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
Next, we use all the same Matplotlib methods as before, but instead of displaying the
result on a graphical terminal using <tt class="doctest"><span class="pre">pyplot.show()</span></tt>, we save it to a file
using <tt class="doctest"><span class="pre">pyplot.savefig()</span></tt> <a class="reference internal" href="#pyplot-savefig"><span id="ref-pyplot-savefig"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.  We specify the filename
then print HTML markup that directs the web browser to load the file.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> from matplotlib import use, pyplot
>>> use('Agg') # [_agg-backend]
>>> pyplot.savefig('modals.png') # [_pyplot-savefig]
>>> print('Content-Type: text/html')
>>> print()
>>> print('<html><body>')
>>> print('<img src="modals.png"/>')
>>> print('</body></html>')</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="networkx">
<h3>NetworkX</h3>
<p>The NetworkX package is for defining and manipulating structures consisting of
nodes and edges, known as <a name="graphs_index_term" /><span class="termdef">graphs</span>.  It is
available from <tt class="doctest"><span class="pre">https://networkx.lanl.gov/</span></tt>.
NetworkX can be used in conjunction with Matplotlib to
visualize networks, such as WordNet (the semantic network we
introduced in <a href="#id25"><span class="problematic" id="id26">sec-wordnet_</span></a>).  The program in <a class="reference internal" href="#code-networkx">4.13</a>
initializes an empty graph <a class="reference internal" href="#define-graph"><span id="ref-define-graph"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a> then traverses
the WordNet hypernym hierarchy adding edges to
the graph <a class="reference internal" href="#add-edge"><span id="ref-add-edge"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
Notice that the traversal is recursive <a class="reference internal" href="#recursive-traversal"><span id="ref-recursive-traversal"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>,
applying the programming technique discussed in
<a class="reference internal" href="#sec-algorithm-design">4.7</a>.  The resulting display is shown in <a class="reference internal" href="#fig-dog-graph">fig-dog-graph</a>.</p>
<span class="target" id="code-networkx"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">import networkx as nx
import matplotlib
from nltk.corpus import wordnet as wn

def traverse(graph, start, node):
    graph.depth[node.name] = node.shortest_path_distance(start)
    for child in node.hyponyms():
        graph.add_edge(node.name, child.name) # [_add-edge]
        traverse(graph, start, child) # [_recursive-traversal]

def hyponym_graph(start):
    G = nx.Graph() # [_define-graph]
    G.depth = {}
    traverse(G, start, start)
    return G

def graph_draw(graph):
    nx.draw_graphviz(graph,
         node_size = [16 * graph.degree(n) for n in graph],
         node_color = [graph.depth[n] for n in graph],
         with_labels = False)
    matplotlib.pyplot.show()</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> dog = wn.synset('dog.n.01')
>>> graph = hyponym_graph(dog)
>>> graph_draw(graph)</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_networkx.py" type="text/x-python"><span class="caption-label">Example 4.13 (code_networkx.py)</span></a>: <span class="caption-label">Figure 4.13</span>: Using the NetworkX and Matplotlib Libraries</td></tr></p>
</table></div>
<div class="system-message" id="fig-dog-graph">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2424)</p>
<p>Error in &quot;figure&quot; directive:
invalid option value: (option: &quot;scale&quot;; value: '80:80:80')
invalid literal for int() with base 10: '80:80:80'.</p>
<pre class="literal-block">
.. figure:: ../images/dog-graph.png
   :scale: 80:80:80

   Visualization with NetworkX and Matplotlib: Part of the WordNet hypernym
   hierarchy is displayed, starting with ``dog.n.01`` (the darkest node in the middle);
   node size is based on the number of children of the node, and color is based on
   the distance of the node from ``dog.n.01``; this visualization was produced
   by the program in code-networkx_.

</pre>
</div>
</div>
<div class="section" id="csv">
<h3>csv</h3>
<p>Language analysis work often involves data tabulations, containing information
about lexical items, or the participants in an empirical study, or the linguistic
features extracted from a corpus.  Here's a fragment of a simple lexicon, in CSV format:</p>
<div class="line-block">
<div class="line">sleep, sli:p, v.i, a condition of body and mind ...</div>
<div class="line">walk, wo:k, v.intr, progress by lifting and setting down each foot ...</div>
<div class="line">wake, weik, intrans, cease to sleep</div>
</div>
<p>We can use Python's CSV library to read and write files stored in this format.
For example, we can open a CSV file called <tt class="doctest"><span class="pre">lexicon.csv</span></tt> <a class="reference internal" href="#open-csv"><span id="ref-open-csv"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>
and iterate over its rows <a class="reference internal" href="#iterate-csv"><span id="ref-iterate-csv"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> import csv
>>> input_file = open("lexicon.csv", "rb") # [_open-csv]
>>> for row in csv.reader(input_file): # [_iterate-csv]
...     print(row)
['sleep', 'sli:p', 'v.i', 'a condition of body and mind ...']
['walk', 'wo:k', 'v.intr', 'progress by lifting and setting down each foot ...']
['wake', 'weik', 'intrans', 'cease to sleep']</td>
</tr></table></td></tr>
</table></div>
<p>Each row is just a list of strings.  If any fields contain numerical
data, they will appear as strings, and will have to be converted using
<tt class="doctest"><span class="pre">int()</span></tt> or <tt class="doctest"><span class="pre">float()</span></tt>.</p>
</div>
<div class="section" id="numpy">
<h3>NumPy</h3>
<p>The NumPy package provides substantial support for numerical processing in Python.
NumPy has a multi-dimensional array object, which is easy to initialize and access:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> from numpy import array
>>> cube = array([ [[0,0,0], [1,1,1], [2,2,2]],
...                [[3,3,3], [4,4,4], [5,5,5]],
...                [[6,6,6], [7,7,7], [8,8,8]] ])
>>> cube[1,1,1]
4
>>> cube[2].transpose()
array([[6, 7, 8],
       [6, 7, 8],
       [6, 7, 8]])
>>> cube[2,1:]
array([[7, 7, 7],
       [8, 8, 8]])</td>
</tr></table></td></tr>
</table></div>
<p>NumPy includes linear algebra functions.  Here we perform
singular value decomposition on a matrix, an operation used
in <a name="latent_semantic_analysis_index_term" /><span class="termdef">latent semantic analysis</span> to help identify implicit
concepts in a document collection.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> from numpy import linalg
>>> a=array([[4,0], [3,-5]])
>>> u,s,vt = linalg.svd(a)
>>> u
array([[-0.4472136 , -0.89442719],
       [-0.89442719,  0.4472136 ]])
>>> s
array([ 6.32455532,  3.16227766])
>>> vt
array([[-0.70710678,  0.70710678],
       [-0.70710678, -0.70710678]])</td>
</tr></table></td></tr>
</table></div>
<p>NLTK's clustering package <tt class="doctest"><span class="pre">nltk.cluster</span></tt> makes extensive use of NumPy arrays,
and includes support for <span class="math">k</span>-means clustering, Gaussian EM clustering,
group average agglomerative clustering, and dendrogram plots.
For details, type <tt class="doctest"><span class="pre">help(nltk.cluster)</span></tt>.</p>
</div>
<div class="section" id="other-python-libraries">
<h3>Other Python Libraries</h3>
<p>There are many other Python libraries, and you can search for them with the
help of the Python Package Index <tt class="doctest"><span class="pre">http://pypi.python.org/</span></tt>.
Many libraries provide an interface to external software, such
as relational databases (e.g. <tt class="doctest"><span class="pre">mysql-python</span></tt>)
and large document collections (e.g. <tt class="doctest"><span class="pre">PyLucene</span></tt>).
Many other libraries give access to file formats
such as PDF, MSWord, and XML (<tt class="doctest"><span class="pre">pypdf</span></tt>, <tt class="doctest"><span class="pre">pywin32</span></tt>, <tt class="doctest"><span class="pre">xml.etree</span></tt>),
RSS feeds (e.g. <tt class="doctest"><span class="pre">feedparser</span></tt>),
and electronic mail (e.g. <tt class="doctest"><span class="pre">imaplib</span></tt>, <tt class="doctest"><span class="pre">email</span></tt>).</p>
</div>
</div>
<div class="section" id="summary">
<h2>4.9&nbsp;&nbsp;&nbsp;Summary</h2>
<ul class="simple">
<li>Python's assignment and parameter passing use object references;
e.g. if <tt class="doctest"><span class="pre">a</span></tt> is a list and we assign <tt class="doctest"><span class="pre">b = a</span></tt>, then any operation
on <tt class="doctest"><span class="pre">a</span></tt> will modify <tt class="doctest"><span class="pre">b</span></tt>, and vice versa.</li>
<li>The <tt class="doctest"><span class="pre">is</span></tt> operation tests if two objects are identical internal objects,
while <tt class="doctest"><span class="pre">==</span></tt> tests if two objects are equivalent.  This distinction
parallels the type-token distinction.</li>
<li>Strings, lists and tuples are different kinds of sequence object, supporting
common operations such as indexing, slicing, <tt class="doctest"><span class="pre">len()</span></tt>, <tt class="doctest"><span class="pre">sorted()</span></tt>, and
membership testing using <tt class="doctest"><span class="pre">in</span></tt>.</li>
<li>A declarative programming style usually produces more compact,
readable code; manually-incremented loop variables are usually
unnecessary; when a sequence must be enumerated, use <tt class="doctest"><span class="pre">enumerate()</span></tt>.</li>
<li>Functions are an essential programming abstraction: key concepts
to understand are parameter passing, variable scope, and docstrings.</li>
<li>A function serves as a namespace: names defined inside a function are not visible
outside that function, unless those names are declared to be global.</li>
<li>Modules permit logically-related material to be localized in a file.
A module serves as a namespace: names defined in a module &#8212; such as variables
and functions &#8212; are not visible to other modules, unless those names are imported.</li>
<li>Dynamic programming is an algorithm design technique used widely in NLP
that stores the results of previous computations in order to avoid
unnecessary recomputation.</li>
</ul>
</div>
<div class="section" id="further-reading">
<h2>4.10&nbsp;&nbsp;&nbsp;Further Reading</h2>
<p>This chapter has touched on many topics in programming, some specific to Python,
and some quite general.  We've just scratched the surface, and you may want
to read more about these topics, starting with the further materials for
this chapter available at <tt class="doctest"><span class="pre">http://nltk.org/</span></tt>.</p>
<p>The Python website provides extensive documentation.  It is important to
understand the built-in functions and standard types, described at
<tt class="doctest"><span class="pre">http://docs.python.org/library/functions.html</span></tt> and
<tt class="doctest"><span class="pre">http://docs.python.org/library/stdtypes.html</span></tt>.
We have learnt about generators and their importance for efficiency;
for information about iterators, a closely related topic,
see <tt class="doctest"><span class="pre">http://docs.python.org/library/itertools.html</span></tt>.
Consult your favorite Python book for more information on such topics.
An excellent resource for using Python for multimedia processing,
including working with sound files, is <a href="#id27"><span class="problematic" id="id1">[Guzdial2005]_</span></a>.</p>
<p>When using the online Python documentation, be aware that
your installed version might be different from the version
of the documentation you are reading.  You can easily
check what version you have, with <tt class="doctest"><span class="pre">import sys; sys.version</span></tt>.
Version-specific documentation is available at
<tt class="doctest"><span class="pre">http://www.python.org/doc/versions/</span></tt>.</p>
<p>Algorithm design is a rich field within computer science.  Some
good starting points are <a href="#id28"><span class="problematic" id="id2">[Harel2004]_</span></a>, <a href="#id29"><span class="problematic" id="id3">[Levitin2004]_</span></a>, <a href="#id30"><span class="problematic" id="id4">[Knuth2006Trees]_</span></a>.
Useful guidance on the practice of software development is provided
in <a href="#id31"><span class="problematic" id="id5">[Hunt2000]_</span></a> and <a href="#id32"><span class="problematic" id="id6">[McConnell2004]_</span></a>.</p>
</div>
<div class="section" id="exercises">
<h2>4.11&nbsp;&nbsp;&nbsp;Exercises</h2>
<ol class="arabic">
<li><p class="first">&#9788; Find out more about sequence objects using Python's help facility.
In the interpreter, type <tt class="doctest"><span class="pre">help(str)</span></tt>, <tt class="doctest"><span class="pre">help(list)</span></tt>, and <tt class="doctest"><span class="pre">help(tuple)</span></tt>.
This will give you a full list of the functions supported by each type.
Some functions have special names flanked with underscore; as the
help documentation shows, each such function corresponds to something
more familiar.  For example <tt class="doctest"><span class="pre">x.__getitem__(y)</span></tt> is just a long-winded
way of saying <tt class="doctest"><span class="pre">x[y]</span></tt>.</p>
</li>
<li><p class="first">&#9788; Identify three operations that can be performed on both tuples
and lists.  Identify three list operations that cannot be performed on
tuples.  Name a context where using a list instead of a tuple generates
a Python error.</p>
</li>
<li><p class="first">&#9788; Find out how to create a tuple consisting of a single item.
There are at least two ways to do this.</p>
</li>
<li><p class="first">&#9788; Create a list <tt class="doctest"><span class="pre">words = ['is', 'NLP', 'fun', '?']</span></tt>.  Use
a series of assignment statements (e.g. <tt class="doctest"><span class="pre">words[1] = words[2]</span></tt>)
and a temporary variable <tt class="doctest"><span class="pre">tmp</span></tt> to transform this list into the
list <tt class="doctest"><span class="pre">['NLP', 'is', 'fun', '!']</span></tt>.  Now do the same transformation
using tuple assignment.</p>
</li>
<li><p class="first">&#9788; Read about the built-in comparison function <tt class="doctest"><span class="pre">cmp</span></tt>, by
typing <tt class="doctest"><span class="pre">help(cmp)</span></tt>.  How does it differ in behavior from
the comparison operators?</p>
</li>
<li><p class="first">&#9788; Does the method for creating a sliding window of n-grams
behave correctly for the two limiting cases: <span class="math">n</span> = 1, and <span class="math">n</span> = <tt class="doctest"><span class="pre">len(sent)</span></tt>?</p>
</li>
<li><p class="first">&#9788; We pointed out that when empty strings and empty lists occur
in the condition part of an <tt class="doctest"><span class="pre">if</span></tt> clause, they evaluate to
<tt class="doctest"><span class="pre">False</span></tt>. In this case, they are said to be occurring in a
Boolean context.
Experiment with different kind of non-Boolean expressions in Boolean
contexts, and see whether they evaluate as <tt class="doctest"><span class="pre">True</span></tt> or <tt class="doctest"><span class="pre">False</span></tt>.</p>
</li>
<li><p class="first">&#9788; Use the inequality operators to compare strings, e.g.
<tt class="doctest"><span class="pre">'Monty' < 'Python'</span></tt>.  What happens when you do <tt class="doctest"><span class="pre">'Z' < 'a'</span></tt>?
Try pairs of strings which have a common prefix, e.g. <tt class="doctest"><span class="pre">'Monty' < 'Montague'</span></tt>.
Read up on &quot;lexicographical sort&quot; in order to understand what is
going on here.  Try comparing structured objects, e.g.
<tt class="doctest"><span class="pre">('Monty', 1) < ('Monty', 2)</span></tt>.  Does this behave as expected?</p>
</li>
<li><p class="first">&#9788; Write code that removes whitespace at the beginning and end of a
string, and normalizes whitespace between words to be a single
space character.</p>
<ol class="arabic simple">
<li>do this task using <tt class="doctest"><span class="pre">split()</span></tt> and <tt class="doctest"><span class="pre">join()</span></tt></li>
<li>do this task using regular expression substitutions</li>
</ol>
</li>
<li><p class="first">&#9788; Write a program to sort words by length.  Define a helper function
<tt class="doctest"><span class="pre">cmp_len</span></tt> which uses the <tt class="doctest"><span class="pre">cmp</span></tt> comparison function on word lengths.</p>
</li>
<li><p class="first">&#9681; Create a list of words and store it in a variable <tt class="doctest"><span class="pre">sent1</span></tt>.
Now assign <tt class="doctest"><span class="pre">sent2 = sent1</span></tt>.  Modify one of the items in <tt class="doctest"><span class="pre">sent1</span></tt>
and verify that <tt class="doctest"><span class="pre">sent2</span></tt> has changed.</p>
<ol class="loweralpha simple">
<li>Now try the same exercise but instead assign <tt class="doctest"><span class="pre">sent2 = sent1[:]</span></tt>.
Modify <tt class="doctest"><span class="pre">sent1</span></tt> again and see what happens to <tt class="doctest"><span class="pre">sent2</span></tt>.  Explain.</li>
<li>Now define <tt class="doctest"><span class="pre">text1</span></tt> to be a list of lists of strings (e.g. to
represent a text consisting of multiple sentences.  Now assign
<tt class="doctest"><span class="pre">text2 = text1[:]</span></tt>, assign a new value to one of the words,
e.g. <tt class="doctest"><span class="pre">text1[1][1] = 'Monty'</span></tt>.  Check what this did to <tt class="doctest"><span class="pre">text2</span></tt>.
Explain.</li>
<li>Load Python's <tt class="doctest"><span class="pre">deepcopy()</span></tt> function (i.e. <tt class="doctest"><span class="pre">from copy import deepcopy</span></tt>),
consult its documentation, and test that it makes a fresh copy of any
object.</li>
</ol>
</li>
<li><p class="first">&#9681; Initialize an <em>n</em>-by-<em>m</em> list of lists of empty strings using list
multiplication, e.g. <tt class="doctest"><span class="pre">word_table = [[''] * n] * m</span></tt>.  What happens
when you set one of its values, e.g. <tt class="doctest"><span class="pre">word_table[1][2] = "hello"</span></tt>?
Explain why this happens.  Now write an expression using <tt class="doctest"><span class="pre">range()</span></tt>
to construct a list of lists, and show that it does not have this problem.</p>
</li>
<li><p class="first">&#9681; Write code to initialize a two-dimensional array of sets called
<tt class="doctest"><span class="pre">word_vowels</span></tt> and process a list of words, adding each
word to <tt class="doctest"><span class="pre">word_vowels[l][v]</span></tt> where <tt class="doctest"><span class="pre">l</span></tt> is the length of the word and <tt class="doctest"><span class="pre">v</span></tt> is
the number of vowels it contains.</p>
</li>
<li><p class="first">&#9681; Write a function <tt class="doctest"><span class="pre">novel10(text)</span></tt> that prints any word that
appeared in the last 10% of a text that had not been encountered earlier.</p>
</li>
<li><p class="first">&#9681; Write a program that takes a sentence expressed as a single string,
splits it and counts up the words.  Get it to print out each word and the
word's frequency, one per line, in alphabetical order.</p>
</li>
<li><p class="first">&#9681; Read up on Gematria, a method for assigning numbers to words, and for
mapping between words having the same number to discover the hidden meaning of
texts (<tt class="doctest"><span class="pre">http://en.wikipedia.org/wiki/Gematria</span></tt>, <tt class="doctest"><span class="pre">http://essenes.net/gemcal.htm</span></tt>).</p>
<ol class="loweralpha">
<li><p class="first">Write a function <tt class="doctest"><span class="pre">gematria()</span></tt> that sums the numerical values of
the letters of a word, according to the letter values in <tt class="doctest"><span class="pre">letter_vals</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc">>>> letter_vals = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5, 'f':80, 'g':3, 'h':8,
... 'i':10, 'j':10, 'k':20, 'l':30, 'm':40, 'n':50, 'o':70, 'p':80, 'q':100,
... 'r':200, 's':300, 't':400, 'u':6, 'v':6, 'w':800, 'x':60, 'y':10, 'z':7}</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">Process a corpus (e.g. <tt class="doctest"><span class="pre">nltk.corpus.state_union</span></tt>) and for each document, count how
many of its words have the number 666.</p>
</li>
<li><p class="first">Write a function <tt class="doctest"><span class="pre">decode()</span></tt> to process a text, randomly replacing words with
their Gematria equivalents, in order to discover the &quot;hidden meaning&quot; of the text.</p>
</li>
</ol>
</li>
<li><p class="first">&#9681; Write a function <tt class="doctest"><span class="pre">shorten(text, n)</span></tt> to process a text, omitting the <span class="math">n</span>
most frequently occurring words of the text.  How readable is it?</p>
</li>
<li><p class="first">&#9681; Write code to print out an index for a lexicon, allowing someone
to look up words according to their meanings (or pronunciations; whatever
properties are contained in lexical entries).</p>
</li>
<li><p class="first">&#9681; Write a list comprehension that sorts a list of WordNet synsets for
proximity to a given synset.  For example, given the synsets
<tt class="doctest"><span class="pre">minke_whale.n.01</span></tt>, <tt class="doctest"><span class="pre">orca.n.01</span></tt>, <tt class="doctest"><span class="pre">novel.n.01</span></tt>, and <tt class="doctest"><span class="pre">tortoise.n.01</span></tt>,
sort them according to their <tt class="doctest"><span class="pre">shortest_path_distance()</span></tt> from <tt class="doctest"><span class="pre">right_whale.n.01</span></tt>.</p>
</li>
<li><p class="first">&#9681; Write a function that takes a list of words (containing duplicates) and
returns a list of words (with no duplicates) sorted by decreasing frequency.
E.g. if the input list contained 10 instances of the word <tt class="doctest"><span class="pre">table</span></tt> and 9 instances
of the word <tt class="doctest"><span class="pre">chair</span></tt>, then <tt class="doctest"><span class="pre">table</span></tt> would appear before <tt class="doctest"><span class="pre">chair</span></tt> in the output
list.</p>
</li>
<li><p class="first">&#9681; Write a function that takes a text and a vocabulary as its arguments
and returns the set of words that appear in the text but not in the
vocabulary.  Both arguments can be represented as lists of strings.
Can you do this in a single line, using <tt class="doctest"><span class="pre">set.difference()</span></tt>?</p>
</li>
<li><p class="first">&#9681; Import the <tt class="doctest"><span class="pre">itemgetter()</span></tt> function from the <tt class="doctest"><span class="pre">operator</span></tt> module in Python's
standard library (i.e. <tt class="doctest"><span class="pre">from operator import itemgetter</span></tt>).  Create a list
<tt class="doctest"><span class="pre">words</span></tt> containing several words.  Now try calling:
<tt class="doctest"><span class="pre">sorted(words, key=itemgetter(1))</span></tt>, and <tt class="doctest"><span class="pre">sorted(words, key=itemgetter(-1))</span></tt>.
Explain what <tt class="doctest"><span class="pre">itemgetter()</span></tt> is doing.</p>
</li>
<li><p class="first">&#9681; Write a recursive function <tt class="doctest"><span class="pre">lookup(trie, key)</span></tt> that looks up a key in a trie,
and returns the value it finds.  Extend the function to return a word when it is uniquely
determined by its prefix (e.g. <tt class="doctest"><span class="pre">vanguard</span></tt> is the only word that starts with <tt class="doctest"><span class="pre">vang-</span></tt>,
so <tt class="doctest"><span class="pre">lookup(trie, 'vang')</span></tt> should return the same thing as <tt class="doctest"><span class="pre">lookup(trie, 'vanguard')</span></tt>).</p>
</li>
<li><p class="first">&#9681; Read up on &quot;keyword linkage&quot; (chapter 5 of <a href="#id33"><span class="problematic" id="id7">[Scott2006]_</span></a>).  Extract keywords from
NLTK's Shakespeare Corpus and using the NetworkX package, plot keyword linkage networks.</p>
</li>
<li><p class="first">&#9681; Read about string edit distance and the Levenshtein Algorithm.
Try the implementation provided in <tt class="doctest"><span class="pre">nltk.edit_distance()</span></tt>.
In what way is this using dynamic programming?  Does it use the bottom-up or
top-down approach?
[See also <tt class="doctest"><span class="pre">http://norvig.com/spell-correct.html</span></tt>]</p>
</li>
<li><p class="first">&#9681; The Catalan numbers arise in many applications of combinatorial mathematics,
including the counting of parse trees (<a href="#id34"><span class="problematic" id="id35">sec-grammar-development_</span></a>).  The series
can be defined as follows: C<sub>0</sub> = 1, and
C<sub>n+1</sub> = &#931;<sub>0..n</sub> (C<sub>i</sub>C<sub>n-i</sub>).</p>
<ol class="loweralpha simple">
<li>Write a recursive function to compute <span class="math">n</span>th Catalan number C<sub>n</sub>.</li>
<li>Now write another function that does this computation using dynamic programming.</li>
<li>Use the <tt class="doctest"><span class="pre">timeit</span></tt> module to compare the performance of these functions as <span class="math">n</span>
increases.</li>
</ol>
</li>
<li><p class="first">&#9733;
Reproduce some of the results of <a href="#id36"><span class="problematic" id="id8">[Zhao07]_</span></a> concerning authorship identification.</p>
</li>
<li><p class="first">&#9733; Study gender-specific lexical choice, and see if you can
reproduce some of the results of <tt class="doctest"><span class="pre">http://www.clintoneast.com/articles/words.php</span></tt></p>
</li>
<li><p class="first">&#9733; Write a recursive function that pretty prints a trie in alphabetically
sorted order, e.g.:</p>
<pre class="literal-block">
chair: 'flesh'
---t: 'cat'
--ic: 'stylish'
---en: 'dog'
</pre>
</li>
<li><p class="first">&#9733; With the help of the trie data structure, write a recursive
function that processes text, locating the uniqueness point in
each word, and discarding the remainder of each word.  How much compression does this
give?  How readable is the resulting text?</p>
</li>
<li><p class="first">&#9733; Obtain some raw text, in the form of a single, long string.
Use Python's <tt class="doctest"><span class="pre">textwrap</span></tt> module to break it up into multiple lines.
Now write code to add extra spaces between words, in order to justify
the output.  Each line must have the same width, and spaces must be
approximately evenly distributed across each line.  No line can
begin or end with a space.</p>
</li>
<li><p class="first">&#9733; Develop a simple extractive summarization tool, that prints the
sentences of a document which contain the highest total word
frequency.  Use <tt class="doctest"><span class="pre">FreqDist()</span></tt> to count word frequencies, and use
<tt class="doctest"><span class="pre">sum</span></tt> to sum the frequencies of the words in each sentence.
Rank the sentences according to their score.  Finally, print the <em>n</em>
highest-scoring sentences in document order.  Carefully review the
design of your program, especially your approach to this double
sorting.  Make sure the program is written as clearly as possible.</p>
</li>
<li><p class="first">&#9733;
Read the following article on semantic orientation of adjectives.
Use the NetworkX package to visualize
a network of adjectives with edges to indicate same vs different
semantic orientation.  <tt class="doctest"><span class="pre">http://www.aclweb.org/anthology/P97-1023</span></tt></p>
</li>
<li><p class="first">&#9733;
Design an algorithm to find the &quot;statistically improbable
phrases&quot; of a document collection.
<tt class="doctest"><span class="pre">http://www.amazon.com/gp/search-inside/sipshelp.html</span></tt></p>
</li>
<li><p class="first">&#9733; Write a program to implement a brute-force algorithm for
discovering word squares, a kind of <span class="math">n</span> &#215; <span class="math">n</span> crossword
in which the entry in the <span class="math">n</span>th row is the same as the entry
in the <span class="math">n</span>th column.  For discussion, see
<tt class="doctest"><span class="pre">http://itre.cis.upenn.edu/~myl/languagelog/archives/002679.html</span></tt></p>
</li>
</ol>
<!-- #. |hard| Extend the program in Example compound-keys_ in the following ways:

a) Define two sets ``verbs`` and ``preps``, and add each verb and preposition
   as they are encountered.  (Note that you can add an item to a set without
   bothering to check whether it is already present.)

b) Create nested loops to display the results, iterating over verbs and
   prepositions in sorted order.  Generate one line of output per verb,
   listing prepositions and attachment ratios as follows:
   ``raised: about 0:3, at 1:0, by 9:0, for 3:6, from 5:0, in 5:5...``

c) We used a tuple to represent a compound key consisting of two strings.
   However, we could have simply concatenated the strings, e.g.
   ``key = verb + ":" + prep``, resulting in a simple string key.
   Why is it better to use tuples for compound keys? -->
<!-- Footer to be used in all chapters -->
<div class="admonition admonition-about-this-document">
<p class="first admonition-title">About this document...</p>
<p>UPDATED FOR NLTK 3.0.
This is a chapter from <em>Natural Language Processing with Python</em>,
by <a class="reference external" href="http://estive.net/">Steven Bird</a>, <a class="reference external" href="http://homepages.inf.ed.ac.uk/ewan/">Ewan Klein</a> and <a class="reference external" href="http://ed.loper.org/">Edward Loper</a>,
Copyright &#169; 2014 the authors.
It is distributed with the <em>Natural Language Toolkit</em> [<tt class="doctest"><span class="pre">http://nltk.org/</span></tt>],
Version 3.0, under the terms of the
<em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</em>
[<a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">This document was built on
Wed 20 Aug 2014 11:10:48 GET</p>
</div>
</div>
</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id9">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 843); <em><a href="#id10">backlink</a></em></p>
Unknown target name: &quot;sec-reusing-code&quot;.</div>
<div class="system-message" id="id11">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 1394); <em><a href="#id12">backlink</a></em></p>
Unknown target name: &quot;chap-parse&quot;.</div>
<div class="system-message" id="id13">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 1470); <em><a href="#id14">backlink</a></em></p>
Unknown target name: &quot;sec-dictionaries&quot;.</div>
<div class="system-message" id="id15">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 1791); <em><a href="#id16">backlink</a></em></p>
Unknown target name: &quot;first-run&quot;.</div>
<div class="system-message" id="id17">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 1791); <em><a href="#id18">backlink</a></em></p>
Unknown target name: &quot;second-run&quot;.</div>
<div class="system-message" id="id19">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 1996); <em><a href="#id20">backlink</a></em></p>
Unknown target name: &quot;sec-dictionaries&quot;.</div>
<div class="system-message" id="id21">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2269); <em><a href="#id22">backlink</a></em></p>
Unknown target name: &quot;sec-parsing&quot;.</div>
<div class="system-message" id="id23">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2292); <em><a href="#id24">backlink</a></em></p>
Unknown target name: &quot;code-modal-tabulate&quot;.</div>
<div class="system-message" id="id25">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2379); <em><a href="#id26">backlink</a></em></p>
Unknown target name: &quot;sec-wordnet&quot;.</div>
<div class="system-message" id="id27">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2559); <em><a href="#id1">backlink</a></em></p>
Unknown target name: &quot;guzdial2005&quot;.</div>
<div class="system-message" id="id28">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2577); <em><a href="#id2">backlink</a></em></p>
Unknown target name: &quot;harel2004&quot;.</div>
<div class="system-message" id="id29">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2577); <em><a href="#id3">backlink</a></em></p>
Unknown target name: &quot;levitin2004&quot;.</div>
<div class="system-message" id="id30">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2577); <em><a href="#id4">backlink</a></em></p>
Unknown target name: &quot;knuth2006trees&quot;.</div>
<div class="system-message" id="id31">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2577); <em><a href="#id5">backlink</a></em></p>
Unknown target name: &quot;hunt2000&quot;.</div>
<div class="system-message" id="id32">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2577); <em><a href="#id6">backlink</a></em></p>
Unknown target name: &quot;mcconnell2004&quot;.</div>
<div class="system-message" id="id33">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2724); <em><a href="#id7">backlink</a></em></p>
Unknown target name: &quot;scott2006&quot;.</div>
<div class="system-message" id="id34">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2733); <em><a href="#id35">backlink</a></em></p>
Unknown target name: &quot;sec-grammar-development&quot;.</div>
<div class="system-message" id="id36">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">/home/user/.pr/nltk_book/book/ch04.rst</tt>, line 2745); <em><a href="#id8">backlink</a></em></p>
Unknown target name: &quot;zhao07&quot;.</div>
</div>
</div>
</body>
</html>
